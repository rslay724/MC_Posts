[POST_VERSION] #DO NOT MOVE OR ALTER THIS LINE# V26.00 P4 E1 W26.00 T1707161831 M26.00 I0 O0
# Customer                : Kimray (Oklahoma City)
# Post Name              : OKUMA_2SP-V760EXM_RIGHT
# Product                  : LATHE
# Machine Name        : Okuma 2SP V760 EX M
# Control Name         : Okuma OSP P300L
# Description             : LATHE C-AXIS POST Right Spindle Only
# Mill/Turn                  : YES
# 4-axis/Axis subs.     : YES
# 5-axis                      : NO
# Subprograms          : YES
# Canned Cycles        : YES
# Executable              : MP.DLL
#
# WARNING: THIS POST IS GENERIC AND IS INTENDED FOR MODIFICATION TO
# THE MACHINE TOOL REQUIREMENTS AND PERSONAL PREFERENCE.
#
# Associated File List$
# OKUMA_2SP-V760EXM_RIGHT.mcam-lmd
# OKUMA_2SP-V760EXM_RIGHT.mcam-control
# OKUMA_2SP-V760EXM_RIGHT.mcpost
#
# --------------------------------------------------------------------------
# Revision log:
# --------------------------------------------------------------------------
# Programmers Note:
# MLC 08/11/11  -  Initial configuration from x5mplmaster, jcw
# MLC 08/11/11  -  configure for GTECH LB3000, jcw
# MLC 12/01/11  -  add g137_ mult, jcw
# MLC 12/13/11  -  Added rotary axis detection, post will detect if a rotary
#                  axis has been defined and output rotary codes accordingly
#                  rot_axis_label, c_axis_mch, jjm
# MLC 12/20/11  -  update pl_retract, pm_retract, mtlchg$, ltlchg$, jcw
# MLC 12/30/11  -  multiply dia_mult and depthcc for G81 cycles in prcc_call_end, jjm
# MLC 01/13/12  -  Corrected thdpulloff$ formatting, jjm
# MLC 05/15/12  -  initial configuration for Utex Ind., jcw
# MLC 09/07/17  -  initial release, jcw
# MLC 01/10/18  -  update per customer requests, jcw
# MLC 01/11/18  -  update ltlchg$, mtlchg$, jcw
# MLC 02/05/18  -  sync w/ customer changes, and update per request, jcw
# MLC 02/06/18  -  update ltlchg0$, mtlchg0$, jcw
# KRI 11/26/23  -  matched changes that MLC made to the left side post, rbs
# KRI 02/20/24  -  changed use_pitch to 0 and blocked out corrosponding items
# --------------------------------------------------------------------------
# Features:
# --------------------------------------------------------------------------
#######          MILL/TURN FUNCTIONS SUPPORTED BY THIS POST          #######
#
# This post supports Generic Fanuc code output for mill/turn lathes.
# It is designed to support the features of Mastercam X.
#
## NEW FEATURES FOR X
# - Machine definition, control definition and toolpath group parameter read sections added.
# - Variable initialization with CD_VAR are read directly from CD.  Changing these initial values
#     in the post will not effect output.  These values are only processed during the update post routine.
# - Variable initialization with SET_BY_MD or SET_BY_CD are overwritten in this post by parameter or
#     variable settings from MD or CD.
# - Enhanced tool information - Added switch for tool comments (see tool_info)
# - Supports X comments including machine name, group name and group comment output (see pcomment2)
# - Additional date, time and data path output options (see pheader)
# - Support for 10 additional canned text options for X
# - Decimal support for sequence number output (set "Increment sequence number" in CD to a decimal value
#     for output.  I.E. "Increment sequence number" = .5, "Start sequence number" = 10 : N10, N10.5, N11, N11.5, etc...)
# - Switch for output of M00 or M01 at tool change (3 position switch, off, M00, M01 - see prog_stop)
# - Support for seperate XY, XZ and YZ plane/arc variables (see Arc page in CD)
# - Support for X style coolant.  Allows up to 10 different coolants to be turned on/off before, with, or after like
#     canned text.  Coolant output is handled by "coolant" variable and string selector for V9 style coolant,
#     "coolantx" variable and string selector for X style coolant.
#
# User Settings
#-------------------------------------------------------------------------------------------------------
use_gear_t         : 0       #Output Turning gear selection code, 0=no, 1=yes

use_gear_m       : 0       # Output Milling gear selection code, 0=no, 1=yes

user_mi2           : 0       # Absolute or Incremental positioning at top level
                                     # 0 = absolute, 1 = incremental

user_mi10         : 0         # CRF X value    #Set this integer in the canned finish path
                                      # 0=orig, 1=post
                                      # Used to change the initial X value before the canned cycle call to the OD (original)
                                      # X value of the canned rough.  this is a safetly precaution to avoid a rapid approach
                                      # through the part to your lathe canned finish ops.

xref  : 50

yref  : 50

zref  : 50


m_axis               : 3      # Machine Axis's  2 or 3

home_type    : 2     # Work coordinate system: (home_type)
                              # -1 = Reference return / Tool offset positioning.
                              # 0 = G50 with the X and Z home positions.
                              # 1 = X and Z home positions.
                              # 2 = xref, yref and zref postions

# Following Misc. Integers are used:
#
# mi4 - Canned conversion cycle type selection:   (mill only)
#       Mill-
#       Activates milling axis conversation canned cycles (G107 or G137).
#       1 activates the cycle.  Post will change rapid moves to high feed linear moves.
#
# mi5 - Spindle Synch
#       0 = Off
#       1 = On
#
# mi7 - Clamp Code Override     (mill only)
#       0 = Default post decision
#       1 = Force Full Clamp
#       2 = Force Brake / Mid-Clamp
#       3 = Off
#
# mi8 - Thread Cut Mode 0=M32, 1=M33, 2=M34
#
# mi9 - Thread Infeed  0=M73, 1=M74, 2=M75
#
#Canned text:
#  Entering cantext within Mastercam allows the following functions to
#  enable/disable.
#  cantext value:
#  1 = Program Stop =  output the "M00" stop code
#  2 = Optional Stop = output the "M01" optional stop code
#  3 = Block Delete on = turn on block delete codes in NC lines
#  4 = Block Delete off = turn off block delete codes in NC lines
#  5 = Return Tailstock =  output the code to retract the tail stock
#  6 = Advance Tailstock =  output the code to advance the tail stock
#  7 = Return Chute =  output the code to retract the chute
#  8 = Advance Chute =  output the code to advance the chute
#  9 = Exact Stop on = turn on the exact stop code in the NC line
#  10 = Exact Stop off = turn off the exact stop code in the NC line
#  11 to 99 output the value selected
#
#TURN TOOLPATHS:
#Lathe canned cycles:
# Supports lathe canned turning cycles through Mastercam.  This post
# is configured to process them.
#
#MILL TOOLPATHS:
#Mill Layout:
# The term "Reference View" refers to the coordinate system associated
# with the Mill Top view (Alt-F9, the upper gnomon of the three displayed).
# Create the part drawing with the the axis of rotation along the X axis
# of the "Mill Reference View" with the face of the part toward the side
# view (Mill Reference View X plus direction).  The Y plus axis of the
# Mill Reference View indicates the position on the part of C zero
# (View number 3).  The right or left side view are the only legal views
# for face milling.  The view number 3 rotated about the X axis as a
# "single axis rotation" are the only legal views for cross milling
# except for axis substitution where the top view is required.
# Rotation around the part is positive in the CCW direction when viewed
# from the side view.
# (The Chook 'CVIEW' should be used for creating milling tool plane and
# construction plane selections, C axis toolpaths in lathe perform
# this function automatically).
#NOTICE: View number 3 always indicates the location for C zero.  Milling
#        with a turret below the centerline indicates C at 180 degrees.
#
#Mill canned cycles:
#Cylindrical interpolation, G107 canned cycle:
# Cylindrical interpolation is created with axis substitution only.
# Use the Caxis/C_axis Contour toolpath.  Create the geometry from
# view number 4 if the rotation of C axis is CCW.  This prevents producing
# a mirror image.  Wrapped and unwrapped geometry are broken and arcs are
# lost so it is better to create flattened geometry.  Set the parameters
# in Rotary Axis not to 'unroll' and set the correct diameter.
# Use View number 3 as the C0 location.  Set mi4 to activate!
#
#Polar interpolation, G137 canned cycle:
# Polar interpolation is active only for face cutting (Right or Left).
# Use the Caxis/Face Contour toolpath.  Create geometry for the lead in
# and lead out with the start and end position on the View number 3 tool
# axis.  All paths must start and end at the 'C0'location for output to
# be correct.  Chain the entire geometry without using Mastercam leads.
# Set mi4 to activate!
#
#Axis substitution:
# View number 3 is the C zero location on the part and corresponds to the
# Y zero position of the "Mill Reference View".  Positions are wrapped
# from and to the diameter of the part as CCW for the Y positive direction.
# If geometry is drawn from View number 4 (Bottom), it is correct for the
# wrap/unwrap on the diameter.  The radius of the specified diameter is
# added to the Z position in the post.  The Y axis is the only axis to
# be converted with mill/turn.
#
#Simultaneous 4 Axis (11 gcode):
# Full 4 axis toolpaths can be generated from various toolpaths under the
# 'multi-axis' selection (i.e. Rotary 4 axis). All 5 axis paths are
# converted to 4 axis paths where only the angle about the rotation axis
# is resolved. Use View number 3 for the toolplane with all 'multi-axis'.
# 4 and 5 axis toolpaths are converted assuming cross machining only!
#
#Y axis output and machining over part center:
# Output Y axis motion by setting 'Rotary axis/Y axis' in the NC
# parameter page.  This requires a valid Axis Combination in your machine defintion.
# y_axis_mch is set from the axis combination.
# Set 'Rotary axis/Y axis' in a machine with no Y axis (y_axis_mch = 0)
# to force linear/circular position moves in the XZ plane (g18).
# This allows machining over the part center.
#Caution: The machining must stay in the XZ plane at a Y fixed value
# when y_axis_mch = zero because no C (other than the Tplane) or
# Y positions are output!!!  This occurs when selecting C_axis/Cross
# Contour without 'y_axis_mch'.  Use Mill toolpaths for cross profiling.
#
#NOTICE: Milling through the part center with a linear move requires the
#        geometry be broken at the centerline.  Milling through the part
#        center with an arc move in the G18 plane, no Y axis and on the
#        negative side of X, reverses only the arc direction and I sign.
#
#Additional Notes:
# 1) G54 calls are generated where the work offset entry of 0 = G54,
#    1 = G55, etc.
# 2) Metric is applied from the NCI met_tool variable.
# 3) The Tplane angle is added to polar conversion and rotary paths.
# 4) The variable 'absinc' is now pre-defined, set user_mi2 (Misc. Integer) for
#    the 'top level' absolute/incremental program output.  Subprograms are
#    updated through the Mastercam dialog settings for sub-programs.
# 5) Lathe disables coordinate mirror and rotate subprograms.
# 6) When creating tools the diameter/radius should end as even numbers
#    relative to the machine precision. EX. Enter 1.0002 dia. and not
#    1.0001 dia. with a machine accuracy of .0001.
# 7) Transform subprograms are intended for use with G54... workshifts.
# 8) Incremental motion at a toolchange is calculated from the values
#    entered for home position.
#
# END_HEADER$
#
# --------------------------------------------------------------------------
# Debugging and program switches
# --------------------------------------------------------------------------
m_one       :  -1   #Define constant
zero        : 0     #Define constant
one         : 1     #Define constant
two         : 2     #Define constant
three       : 3     #Define constant
four        : 4     #Define constant
five        : 5     #Define constant
oneeighty   : 180   #Define constant
c9k         : 9999  #Define constant

bug4$        : 1     #Append NCI line no. to each NC line?
whatno$      : yes$  #Do not perform whatline branches? (leave as yes)
linktolvar$  : 0     #Associate X tolerance variables to V9- variable?
linkplnvar$  : 0     #Associate X plane specific variables to V9- variable?
linklvar$    : 0     #Associate X lathe specific variables to V9- variable?

skp_lead_flgs$ : 1   #Do NOT use v9 style contour flags
get_1004$    : 0     #Find gcode 1004 with getnextop?
rpd_typ_v7$  : 0     #Use Version 7 style contour flags/processing?
strtool_v7$  : 2     #Use Version 7+ toolname?
tlchng_aft$  : 2     #Delay call to toolchange until move line
cant_tlchng$ : 1     #Ignore cantext entry on move with tlchng_aft
newglobal$   : 1     #Error checking for global variables
getnextop$   : 1     #Build the next variable table
cc_1013$     : 1     #Read cc_pos on the 1013 line, lathe

# --------------------------------------------------------------------------
# General Output Settings
# --------------------------------------------------------------------------
force_wcs    : yes$  #Force WCS output at every toolchange?
progname$    : 1     #Use uppercase for program name
css_start_rpm : yes$   #Do direct RPM spindle start prior to CSS?
css_end_rpm  : no$   #Do direct RPM spindle prior to Retract?
prog_stop    : 1     #Program stop at toolchange: 0=None, 1=M01, 2 = M00
tool_info    : 2     #Output tool information?
                          #0 = Off - Do not output any tool comments or tool table
                          #1 = Tool comments only
                          #2 = Tool table only
                          #3 = Tool comments and tool table
use_pitch    : 0     #0 = Use feed for tapping (force Feed/Min), 1 = Use pitch for tapping (force Feed/Rev)
rigid_tap    : 1     #0 = Floating tap output
                          #1 = Rigid tap output (Set parameter 5200 bit 0 to 1 for rigid)
                          #(Set M code for rigid tap in parameter 5210)
tap_feed     : 1     #0 = 2/1 (in/mm) decimal places, 1 = 4/3 (in/mm) decimal places
thread_address : 0   #Thread pitch address for lathe threading, 0 = Use F, 1 = Use E
use_clamp    : 1     #0 = No, 1 = Clamp
use_brake    : 0     #0 = No, 1 = Brake
lathe_stop   : 0     #Stop lathe spindle on lathe tool change? 0 = no, 1 = yes
drop_offset  : 0     #Drop offset at end of tool? 0 = no, 1 = yes
tseqno       : 2     #Output sequence number at toolchanges when omitseq = yes
                          #0=off, 1=seq numbers match toolchange number, 2=seq numbers match tool number
g54g55       : 0     #0 = Use Mcam Work Offset Logic, 1 = Force G54 for main spindle and G55 for sub spindle
c_resolution : 0.001 #Set your C-axis resolution.  This is used for deg/min feed calcs
                                #Post must only enter pfclc_deg_inv if C motion >= to the resolution of the axis output occurs
checkyflg    : yes$  #Check Y movement only once for error
#cwind        : 0     #0 = No, always start the calc from 0, 1 = Yes, allow C-axis winding for axis subsitution (start at closest rev) #MU00007
cc_seqno     : 0     #If using full sequence numbers engage this switch to correct all lathe sequence numbers including canned cycles.
tap_dir         : 0        # Tap direction flag right/left from parameters
ps_section  : -1     #PS section value from mr1$

#Interpolation Output Settings
g107crad         : 1    #0 = radius, 1 = diameter
g137address   : 0    #0 = Y, 1 = C

# --------------------------------------------------------------------------
# Machine Specific Settings
# --------------------------------------------------------------------------
#Machine axis switches, initial
y_axis_mch  : no$   #SET_BY_MD - Machine has a Y axis, 0=no, 1=yes - Set based on Axis Combination in MD
c_axis_mch  : no$   #SET_BY_MD - Machine has a C axis, 0=no, 1=yes - Set based on Axis Combination in MD
wcs_origin  : 0     #Always use the WCS origin for coordinates
g137_mult  : 1     # Multiplier for G137 Milling Mode
mill_mult   : 2     #Multiplier for output on X axis (Neg. switches sign of X)
dia_mult    : 2     #Multiplier for output on X axis (Neg. switches sign of X)
y_mult      : 1     #Multiplier for output on Y axis (Neg. switches sign of Y)
z_mult      : 1     #Multiplier for output on Z axis (Neg. switches sign of Z)
dia_shift   : 0     #Shift for output on X axis, radial entry
y_shift     : 0     #Shift for output on Y axis
z_shift     : 0     #Shift for output on Z axis
map_home    : yes$   #Use home positions as entered or map to machine axis

#C axis and Index switches
str_cax_abs : "C"     #String address for absolute rotary axis
str_cax_inc : "H"     #String address for incremental rotary axis
str_index   : "B"     #String address for indexer
frc_cinit   : 1     #Force C axis reset at toolchange
c_shift     : 180     #Shift for output on bottom turrets with C axis
ctol        : 270   #Tolerance in deg. of inc. move before 'rev' flag changes
ctable      : 1     #Degrees for each index step with indexing spindle
ixtol       : 0.01  #Tolerance in deg. for index error
maxfrdeg    : 2000   #Limit for feed in deg/min
frdegstp    : 10    #Step limit for rotary feed in deg/min

#Spindle switches and values
cool_w_spd  : 0      #Output coolant with spindle code, 0=no, 1=yes - only available with V9 coolant option in MD
max_speedl0 : 3600   #Maximum spindle speed (lathe), Bottom turret/Left spindle
min_speedl0 : 20     #Minimum spindle speed
max_speedm0 : 4000   #Maximum spindle speed (mill)
min_speedm0 : 50     #Minimum spindle speed
max_speedl1 : 3600   #Maximum spindle speed (lathe), Top turret/Left spindle
min_speedl1 : 20     #Minimum spindle speed
max_speedm1 : 4000   #Maximum spindle speed (mill)
min_speedm1 : 50     #Minimum spindle speed
max_speedl2 : 3600   #Maximum spindle speed (lathe), Bottom turret/Right spindle
min_speedl2 : 20     #Minimum spindle speed
max_speedm2 : 4000   #Maximum spindle speed (mill)
min_speedm2 : 50     #Minimum spindle speed
max_speedl3 : 3600   #Maximum spindle speed (lathe), Top turret/Right spindle
min_speedl3 : 20     #Minimum spindle speed
max_speedm3 : 4000   #Maximum spindle speed (mill)
min_speedm3 : 50     #Minimum spindle speed

#Machining position turret/spindle settings
# Switch strings based on turret position top/bottom-left/right and cut type.
# Turret position is based on the Mastercam settings (see lathtype).
# Strings are re-assigned for output in the routine psw_str_mult.
# The string variable sw_string holds the place position value to determine
# how to assign the strings.  Planes are relative to the view from Mastercam.
# Assign the 17 digit string following the alpha columns below:
# A - C axis, 1 = axis winds, 2 = axis signed, 3 = indexer
# B - Spindle direction, 0 = normal, 1 = reverse
# C - Plane 0 arc/comp, 0 = normal, 1 = switch
# D - Plane 1 arc/comp, 0 = normal, 1 = switch
# E - Plane 2 arc/comp, 0 = normal, 1 = switch
# F - Plane 0, 0 = G17, 1 = G19, 2 = G18
# G - Plane 1, 0 = G17, 1 = G19, 2 = G18
# H - Plane 2, 0 = G17, 1 = G19, 2 = G18
# Decimal (required)
# I - Plane 0, X axis, 0 = normal, 1 = switch sign from basic
# J - Plane 0, Y axis, 0 = normal, 1 = switch sign from basic
# K - Plane 0, Z axis, 0 = normal, 1 = switch sign from basic
# L - Plane 1, X axis, 0 = normal, 1 = switch sign from basic
# M - Plane 1, Y axis, 0 = normal, 1 = switch sign from basic
# N - Plane 1, Z axis, 0 = normal, 1 = switch sign from basic
# O - Plane 2, X axis, 0 = normal, 1 = switch sign from basic
# P - Plane 2, Y axis, 0 = normal, 1 = switch sign from basic
# Q - Plane 2, Z axis, 0 = normal, 1 = switch sign from basic
use_only_tl : 1     #Use only Top turret/Left spindle settings (below) for
                            #all Mastercam turret/spindle selections
                            #When configuring for multi-spindle/turret set to 0

#Columns-       ABCDEFGH.IJKLMNOPQ #Turret/Spindle            #Path Type
scase_tl_c1  : "10000222.100100100"  #Top turret/Left spindle, Turning cut
scase_tl_c2  : "10000012.000000000"  #Top turret/Left spindle, Right Face cut
scase_tl_c_2 : "10110012.000000000"  #Top turret/Left spindle, Left Face cut
scase_tl_c3  : "10010102.000000000"  #Top turret/Left spindle, Cross cut (cuttype = 3)
scase_tl_c3r : "10001102.000000000"  #Top turret/Left spindle, Reverse Cross cut (cuttype = -3)
scase_tl_c4c : "10000222.000000000"  #Top turret/Left spindle, Y axis subs. Cycle
scase_tl_c4  : "10000122.000000000"  #Top turret/Left spindle, Y axis subs.
scase_tl_c5  : "10000222.000000000"  #Top turret/Left spindle, Multisurf Rotary

#Columns-    ABCDEFGH.IJKLMNOPQ
scase_bl_c1  : "10000222.000000000"  #Bottom turret/Left spindle, Turning cut
scase_bl_c2  : "10000222.000000000"  #Bottom turret/Left spindle, Right Face cut
scase_bl_c_2 : "10110222.000000000"  #Bottom turret/Left spindle, Left Face cut
scase_bl_c3  : "10010222.000000000"  #Bottom turret/Left spindle, Cross cut (cuttype = 3)
scase_bl_c3r : "10010222.000000000"  #Bottom turret/Left spindle, Reverse Cross cut (cuttype = -3)
scase_bl_c4c : "10000222.000000000"  #Bottom turret/Left spindle, Y axis subs. Cycle
scase_bl_c4  : "10000222.000000000"  #Bottom turret/Left spindle, Y axis subs.
scase_bl_c5  : "10000222.000000000"  #Bottom turret/Left spindle, Multisurf Rotary

#Columns-    ABCDEFGH.IJKLMNOPQ
scase_tr_c1  : "10000222.000000000"  #Top turret/Right spindle, Turning cut
scase_tr_c2  : "10000012.000000000"  #Top turret/Right spindle, Right Face cut
scase_tr_c_2 : "10110012.000000000"  #Top turret/Right spindle, Left Face cut
scase_tr_c3  : "10010102.000000000"  #Top turret/Right spindle, Cross cut (cuttype = 3)
scase_tr_c3r : "10001102.000000000"  #Top turret/Right spindle, Reverse Cross cut (cuttype = -3)
scase_tr_c4c : "10000222.000000000"  #Top turret/Right spindle, Y axis subs. Cycle
scase_tr_c4  : "10000222.000000000"  #Top turret/Right spindle, Y axis subs.
scase_tr_c5  : "10000222.000000000"  #Top turret/Right spindle, Multisurf Rotary

#Columns-    ABCDEFGH.IJKLMNOPQ
scase_br_c1  : "10000222.000000000"  #Bottom turret/Right spindle, Turning cut
scase_br_c2  : "10000222.000000000"  #Bottom turret/Right spindle, Right Face cut
scase_br_c_2 : "10110222.000000000"  #Bottom turret/Right spindle, Left Face cut
scase_br_c3  : "10010222.000000000"  #Bottom turret/Right spindle, Cross cut (cuttype = 3)
scase_br_c3r : "10010222.000000000"  #Bottom turret/Right spindle, Reverse Cross cut (cuttype = -3)
scase_br_c4c : "10000222.000000000"  #Bottom turret/Right spindle, Y axis subs. Cycle
scase_br_c4  : "10000222.000000000"  #Bottom turret/Right spindle, Y axis subs.
scase_br_c5  : "10000222.000000000"  #Bottom turret/Right spindle, Multisurf Rotary

# --------------------------------------------------------------------------
# Common User-defined Variable Initializations (not switches!)
# --------------------------------------------------------------------------
#Post Setup Variable Initializations (Generally these are not modified)
sub_level$   : 1     #CD_VAR Enable automatic subprogram support
breakarcs$   : 1     #CD_VAR Break arcs, 0 = no, 1 = quadrants, 2 = 180deg. max arcs
arctype$     : 2     #CD_VAR arctype$, arctpeyz$, arctypxz$
                     #Arc center 1=abs, 2=St-Ctr, 3=Ctr-St, 4=unsigned inc.,
                     #5 = R no sign, 6 = R signed neg. over 180
do_full_arc$ : 0     #CD_VAR Allow full circle output? 0=no, 1=yes
helix_arc$   : 0     #CD_VAR Support helix arc output, 0=no, 1=all planes, 2=XY plane only
arccheck$    : 1     #CD_VAR Convert small arcs to linear
atol$        : 0.01  #CD_VAR Angularity tolerance for arccheck
ltol$        : 0.002 #CD_VAR Length tolerance for arccheck
vtol$        : 0.0001 #System tolerance
maxfeedpm    : 300   #Limit for feed in inch/min
lcc_move     : 0.05  #Enter the move in X, Z for lathe canned cycle comp.
vtol_m       : 0.0025 #System tolerance, metric
maxfeedpm_m  : 10000 #Limit for feed in mm/min
lcc_move_m   : 1.25  #Enter the move in X, Z for lathe canned cycle comp.,mm
spaces$      : 1     #CD_VAR Number of spaces to add between fields
omitseq$     : yes$  #CD_VAR Omit sequence numbers? (use -1 to enable sequence for LCC)
seqmax$      : 9999  #CD_VAR Max. sequence number
nobrk$       : no$   #CD_VAR Omit breakup of x, y & z rapid moves
rotaxtyp$    : 3     #Rotary axis type for toolplane
tooltable$   : 3     #Read for tool table and pwrtt (3 recalls pwrtt at sof)

cuttype     : 0     #Flag for cut type
                    #1 = Lathe
                    #2 = Right face cut
                    #-2 = Left face cut
                    #3 = Cross cut
                    #-3 = Reverse Cross cut
                    #4 = Y axis substitution
                    #5 = Multisurf Rotary 4 axis or 11 gcode
lathtype    : 0     #Lathe turret and spindle selection
                    #0 = Bottom turret/Left spindle
                    #1 = Top turret/Left spindle
                    #2 = Bottom turret/Right spindle
                    #3 = Top turret/Right spindle
lathecc     : 0     #Flag for canned turning cycle type
                    #1 = G71/G72 rough cycle
                    #2 = G73 pattern repeating cycle
                    #3 = G74/G75 groove cycle
                    #4 = Finish pass for types 1 and 2
                    #Neg.=rough and finish, Pos.=rough only
millcc      : 0     #Flag for mill conversion cycle type
comp_type   : 0     #Cutter compensation type
                    #0 = Computer
                    #1 = Control
                    #2 = Wear
                    #3 = Reverse wear
                    #4 = Off
metvals     : 0     #Use inch/metric values switch in tool parameters
                    #0 = inch values, 1 = metric values. Affects pitch in tapping

#Cantext activated flags
bld         : 0     #Block delete active
exact       : 0     #Exact stop active
chute       : 0     #Toggle for part catcher operation
tlstk       : 0     #Toggle for tailstock operation

#General user variables
xia         : 0     #Formated absolute value for X
yia         : 0     #Formated absolute value for Y
zia         : 0     #Formated absolute value for Z
cia         : 0     #Formated absolute value for C
copy_x      : 0     #X value copy, prevent compound operations
copy_y      : 0     #Y value copy, prevent compound operations
copy_z      : 0     #Z value copy, prevent compound operations
xa          : 0     #Absolute coordinate mapped value for X
ya          : 0     #Absolute coordinate mapped value for Y
za          : 0     #Absolute coordinate mapped value for Z
cfeed_x     : 0     #Absolute mapped/rotated unshifted value for X
cfeed_y     : 0     #Absolute mapped/rotated unshifted value for Y
cfeed_z     : 0     #Absolute mapped/rotated unshifted value for Z
xca         : 0     #Absolute unshifted value for XC
yca         : 0     #Absolute unshifted value for YC
zca         : 0     #Absolute unshifted value for ZC
sav_xa      : 0     #X saved value
sav_ya      : 0     #Z saved value
sav_za      : 0     #Z saved value
sav_xh      : 0     #X saved value
sav_yh      : 0     #Z saved value
sav_zh      : 0     #Z saved value
start_xh    : 0
start_yh    : 0
start_zh    : 0
sav_cc_1013 : 1     #Capture value of cc_1013 flag  # 1/17/03
clamp_code  : -1    #String select variable
conversion  : 12    #Unit conversion value, do not change
result      : 0     #Return value for functions
compok      : 1     #Flag to output cutter compensation
toolchng    : 2     #On a toolchange flag
toolchng0   : 2     #On a null toolchange flag
plane$      :  -1   #Initialize plane
ipr_actv$   :  -1   #Initialize active feed type
mach_plane  : 0     #Plane mapped to machine
sav_arcout  : arcoutput$ #Arc output type saved
breakarcss  : 0     #saved breakarcs$ value
g71type     : 0     #lathe plunge for G71 type 1 or type 2 cycle
counter     : 0     #Counter
nstrlen     : 0     #Length of string
sav_absinc  : 0     #Saved absolute/Incremental
spd_rev     : 0     #Flag to reverse spindle direction
sav_gcode   : 0     #Gcode saved
sav_feed    : 0     #Feed saved
sav_ipr     : 0     #IPR saved
sav_feedcc  : 0     #Feed saved, canned cycle
sav_iprcc   : 0     #IPR saved, canned cycle
sav_spdir   : 0     #Spindle direction saved
sav_omitsq  : 0     #Omitseq saved
sav_subout  : 0     #Saved subout
sav_frc_wcs : 0     #Force work offset flag saved
sav_bug2    : bug2$  #Saved setting for bug2
sav_cutpos2 : 0     #Patch to handle cutpos2 flag through null toolchnages
sav_eob     : 0     #eob saved
cir_at_zero : 0     #Arc center at centerline in XY plane, -1 if not plane 0
pnt_at_zero : 0     #Position at centerline with milling
c_ax_flp    : 0     #G18 plane with C axis arcs in neg. range
rslt_plc    : 0     #Return value from plcval
rslt_upd    : 0     #Return value from updstr

#Drilling variables
drlgsel     :  -1   #Drill Select Initialize
drillref    :  -1   #Select drill reference
peckacel$   : 0     #Fractional percent to reduce peck2 when usecan.. : no
mdrl_dir    : 0     #Mill drill direction for boolean, 0 = face, 1 = cross
zdrl_x      : 0     #Drill point, mapped X
zdrl_y      : 0     #Drill point, mapped Y
zdrl_z      : 0     #Drill point, mapped Z

#Threading variables
nstart_cnt  : 0     #Counter for multiple threads
thd_vlen    : 0     #Incremental X move for G76 mult starts
xmaj_thd    : 0     #X major dia. from parameters
zstrt_thd   : 0     #Z start from parameters
zend_thd    : 0     #Z end from parameters
face_thd    : 0     #Face thread from parameters

#Spindle variables
max_speed   : 0     #Maximum spindle speed (set by turret definition)
min_speed   : 0     #Minimum spindle speed (set by turret definition)
speedrpm    : 0     #Spindle calculation RPM
g_speed     : 0     #Generic positive spindle speed (rpm or css)
g_spdir     : 999   #Generic spindle direction
speedx      : 0     #Test spindle calculation X position
gear_spd    : 0     #Absolute value of gear speed

# Lathe canned cycle variables
gcodecc     : 0     #Canned turning cycle gcode
y_axis      : 0     #Flag for Y axis machining (implies over center)
directcc    : 0     #Direction from parameters
dopeckcc    : 0     #Do peck from groove parameters
foundcc     : 0     #Return found from G70 read
cc_stop_fcc : 0     #Stop output with rough only
lcc_cc_pos  : 0     #Position for lathe canned cycle cutter comp. enable
lccdirx     : 0     #Canned cycle X vector direction
lccdirz     : 0     #Canned cycle Z vector direction
lcc_xcst    : 0     #Lathe canned cycle contour start position
lcc_ycst    : 0     #Lathe canned cycle contour start position
lcc_zcst    : 0     #Lathe canned cycle contour start position
lcc_xcend   : 0     #Lathe canned cycle contour end position
lcc_ycend   : 0     #Lathe canned cycle contour end position
lcc_zcend   : 0     #Lathe canned cycle contour end position

#_last variables to keep track of previous values (see plast)
last_millcc  : 0     #Previous value of millcc
last_op_id   : 0     #Previous value of op_id$
last_cuttype : 0     #Previous value of cuttype
last_spindle_no : 0  #Previous value of spindle_no$

#_flg variables
interp_flg   : 0     #Interpolation output currently on
clamp_flg    : 0     #Clamp curently on or off
synch_flg    : 0     #Flag for synched spindle work
force_flg  : 0       #Flag to indicate forced output in mtlchg0,ltlchg0

#Vector Variables for Mapping and Rotary Calculations
#Lathe - Uses top matrix - initialize here
m1$          : 1
m5$          : 1
m9$          : 1

vtoolx_rot  : 0
vtooly_rot  : 0
vtoolz_rot  : 0

#A rotation vector
aaxisx      : 1
aaxisy      : 0
aaxisz      : 0

#B rotation vector
baxisx      : 0
baxisy      : 1
baxisz      : 0

#C rotation vector
caxisx      : 0
caxisy      : 0
caxisz      : 1

#Mapping matrix
#Home position mapping matrix
hmtx1       : 1
hmtx2       : 0
hmtx3       : 0
hmtx4       : 0
hmtx5       : 1
hmtx6       : 0
hmtx7       : 0
hmtx8       : 0
hmtx9       : 1

#Cut type mapping matrix
mmtx1       : 1
mmtx2       : 0
mmtx3       : 0
mmtx4       : 0
mmtx5       : 1
mmtx6       : 0
mmtx7       : 0
mmtx8       : 0
mmtx9       : 1

#Side matrix
smtx1       : 0
smtx2       : 1
smtx3       : 0
smtx4       : 0
smtx5       : 0
smtx6       : 1
smtx7       : 1
smtx8       : 0
smtx9       : 0

#Cross matrix
cmtx1       :  -1
cmtx2       : 0
cmtx3       : 0
cmtx4       : 0
cmtx5       : 0
cmtx6       : 1
cmtx7       : 0
cmtx8       : 1
cmtx9       : 0

#Reversed cross matrix
crmtx1      : 1
crmtx2      : 0
crmtx3      : 0
crmtx4      : 0
crmtx5      : 0
crmtx6      : -1
crmtx7      : 0
crmtx8      : 1
crmtx9      : 0

#Back matrix
bmtx1       : 0
bmtx2       :  -1
bmtx3       : 0
bmtx4       : 0
bmtx5       : 0
bmtx6       : 1
bmtx7       :  -1
bmtx8       : 0
bmtx9       : 0

#Axis Subs matrix
amtx1       : 1
amtx2       : 0
amtx3       : 0
amtx4       : 0
amtx5       : 0
amtx6       : 1
amtx7       : 0
amtx8       : 1
amtx9       : 0

#C-axis variables for calculations
one_rev     : 1     #0 = Absolute positioning with wind up, 1 = 0 to 360 closest direction #MU00004
c_axistype  : 0     #1 = C axis winds-up, 2 = C axis signed absolute
                            #3 = index positioning (do not set here, use string)
ipr_type    : 0     #Feedrate for Rotary, 0 = UPM, 1 = DPM
csav        : 0     #Initial c axis result from pxyzcout call
last_csav   : 0     #Initial c axis result from pxyzcout call
czero_csav  : 0     #Save csav when circle at zero detected
c_wnd       : 0     #Calculation for c axis position tracking (abs-wind)
prvc_wnd    : 0     #Saved cout calculation from deg., this is cabs in mpfan
rev         : 0     #C axis wind-up multiplier
prvfrdeg    : 0     #Feedrate deg/min actual
circum      : 0     #Circumference
ldelta      : 0     #Linear distance for deg/min, linear
cdelta      : 0     #Total linear and angular motion for deg/min
cldelta     : 0     #Calculation for deg/min, linear and rotary
sav_rev     : 0     #Saved revolution counter
indx_out    : c9k   #Rotation direction calculation
m1516_flg   : 0     # M15/M16 Direction Flag
fmt     17  frdeg   #Feedrate deg/min actual
fmt     20  indx_mc #Rotation direction calculation

#Coolant variables for X style coolant
cant_pos     : 0    #Read from current canned text (cant_pos1 - cant_pos20)
coolant_bin  : 0    #Binary value for current coolant command
coolant_on   : 0    #Binary value holding the sum of all coolants currently on
coolantx     : 0    #Selector variable for coolant string selector
local_int    : 0    #Local variable for output of coolant off commands
result2      : 0    #Return value for functions
suppress     : 0    #Flag used to suppress redundant coolant on commands
all_cool_off : 0    #SET_BY_MD - First coolant off command shuts off ALL coolant options
v9_coolant   : 0    #SET_BY_MD - Use V9 coolant options - read from General Machine Parameters

#SET BY MD - Variables to capture parameter values - use to set post switches in pset_mach
rot_axis     : 0     #Axis of rotation - 1=X, 2=Y, 3=Z
rot_type     : 0     #Rotary type - 0=signed continuous, 1=signed absolute, 2=shortest direction
rot_dir      : 0     #Rotary direction - CW is positive, 0 = false, 1 = true
rot_index    : 0     #Index or continuous - 0 = continuous, 1 = index
rot_angle    : 0     #Degrees for each index step with indexing spindle
component_type : 0   #Component type: (See documentation for complete list - )
                       #0 = MACHINE
                       #1 = STOCK_COMPONENT
                       #2 = MISC_COMPONENT
                       #3 = MACHINE_BASE_COMPONENT
                       #4 = LINEAR_AXIS_COMPONENT
                       #5 = ROTARY_AXIS_COMPONENT
                       #6 = RECT_TABLE_COMPONENT
                       #12 = CHUCK_COMPONENT
                       #24 = TOOL_SPINDLE_COMPONENT
                       #23 = ATC_COMPONENT
xpos_dir        : 0    #x Axis direction flag
ypos_dir        : 0    #y Axis direction flag
zpos_dir        : 0    #Z Axis direction flag
axis_label   : 0     #Axis label - 1=X,2=Y,3=Z
rot_axis_label : 0   #Rotary axis label - 4=A,5=B,6=C,-1=MACRO
write_ops    : 0     #Write NC operation information (True/False)


#Plane/axis sign modifier (always 1 or -1)
pl_ax_m0x   : 1
pl_ax_m0y   : 1
pl_ax_m0z   : 1
pl_ax_m1x   : 1
pl_ax_m1y   : 1
pl_ax_m1z   : 1
pl_ax_m2x   : 1
pl_ax_m2y   : 1
pl_ax_m2z   : 1

# --------------------------------------------------------------------------
# Buffer definitions
# --------------------------------------------------------------------------
#Buffer 1, toolchange information
wc1           : 1       #Initial count for write buffer 1
rc1           : 1       #Initial count for read buffer 1
nc1           : 2       #Initial count for read buffer 1 into next record
size1         : 0       #Buffer 1 size

# Current tool information
c1_gcode      : 0       #Buffer 1
c1_xh         : 0       #Buffer 1
c1_yh         : 0       #Buffer 1
c1_zh         : 0       #Buffer 1
c1_tox        : 0       #Buffer 1
c1_toy        : 0       #Buffer 1
c1_toz        : 0       #Buffer 1
c1_cc_pos     : 0       #Buffer 1
c1_tool       : 0       #Buffer 1
c1_tloffno    : 0       #Buffer 1
c1_maxss      : 0       #Buffer 1
c1_ss         : 0       #Buffer 1
c1_spdir      : 0       #Buffer 1
c1_css_actv   : 0       #Buffer 1
c1_fr_pos     : 0       #Buffer 1
c1_ipr_actv   : 0       #Buffer 1
c1_coolant    : 0       #Buffer 1
c1_nextdc     : 0       #Buffer 1
c1_posttype   : 0       #Buffer 1
c1_cuttype    : 0       #Buffer 1
c1_lathtype   : 0       #Buffer 1
c1_gcodecc    : 0       #Buffer 1
c1_lathecc    : 0       #Buffer 1
c1_millcc     : 0       #Buffer 1
c1_y_axis     : 0       #Buffer 1
c1_x_min      : 0       #Buffer 1
c1_x_max      : 0       #Buffer 1
c1_spindle_no : 0       #Buffer 1

# Next tool information
n1_gcode      : 0       #Buffer 1
n1_xh         : 0       #Buffer 1
n1_yh         : 0       #Buffer 1
n1_zh         : 0       #Buffer 1
n1_tox        : 0       #Buffer 1
n1_toy        : 0       #Buffer 1
n1_toz        : 0       #Buffer 1
n1_cc_pos     : 0       #Buffer 1
n1_tool       : 0       #Buffer 1
n1_tloffno    : 0       #Buffer 1
n1_maxss      : 0       #Buffer 1
n1_ss         : 0       #Buffer 1
n1_spdir      : 0       #Buffer 1
n1_css_actv   : 0       #Buffer 1
n1_fr_pos     : 0       #Buffer 1
n1_ipr_actv   : 0       #Buffer 1
n1_coolant    : 0       #Buffer 1
n1_nextdc     : 0       #Buffer 1
n1_posttype   : 0       #Buffer 1
n1_cuttype    : 0       #Buffer 1
n1_lathtype   : 0       #Buffer 1
n1_gcodecc    : 0       #Buffer 1
n1_lathecc    : 0       #Buffer 1
n1_millcc     : 0       #Buffer 1
n1_y_axis     : 0       #Buffer 1
n1_x_min      : 0       #Buffer 1
n1_x_max      : 0       #Buffer 1
n1_spindle_no : 0       #Buffer 1

fbuf 1 0 28 0 0         #Buffer 1
# --------------------------------------------------------------------------
#Buffer 2, recall lathe canned turning cycle line numbers
wc2           : 1       #Initial count for write buffer 2
rc2           : 1       #Initial count for read buffer 2
size2         : 0       #Buffer 2 size

fcc_subid     : 0       #Buffer 2
fcc_ng70s     : 0       #Buffer 2
fcc_ng70e     : 0       #Buffer 2

fbuf 2 0 3 0 0          #Buffer 2
# --------------------------------------------------------------------------
#Buffer 3, output strings for lathe canned turning cycles
wc3           : 1       #Initial count for write buffer 3
rc3           : 1       #Initial count for read buffer 3
size3         : 0       #Buffer 3 size

string3 : ""                 #Buffer 3

fbuf 3 0 80 1 1         #Buffer 3
# --------------------------------------------------------------------------
#Buffer 4, used to sav X and Z initial values for lathe canned rough and finish #CRF
wc4           : 1       #Initial count for write buffer 3
rc4           : 1       #Initial count for read buffer 3
size4         : 0       #Buffer 3 size

crf_line      : 0     #Canned cycle line number
crf_xsav1     : 0     #Saved X value before lathe canned rough for use with lathe canned finish
crf_zsav1     : 0     #Saved Z value before lathe canned rough for use with lathe canned finish
crf_xsav2     : 0     #Saved X value before lathe canned rough for use with lathe canned finish
crf_zsav2     : 0     #Saved Z value before lathe canned rough for use with lathe canned finish

fbuf 4 0 2 0 0         #Buffer 3
# --------------------------------------------------------------------------
#String and string selector definitions for NC output
# --------------------------------------------------------------------------
#Address string definitions
stra        : "A"     #String for address A
strb        : "B"     #String for address B
strc        : "C"     #String for address C
strd        : "D"     #String for address D
stre        : "E"     #String for address E
strf        : "F"     #String for address F
strh        : "H"     #String for address H
stri        : "I"     #String for address I
strk        : "K"     #String for address K
strl        : "L"     #String for address L
strm        : "M"     #String for address M
strn        : "N"     #String for address N
stro        : "O"     #String for address O
strp        : "P"     #String for address P
strq        : "Q"     #String for address Q
stru        : "U"     #String for address U
strw        : "W"     #String for address W
strr        : "R"     #String for address R (radius)
srminus     : "L-"    #String for address R- (minus radius)
strs        : "S"     #String for address S
stry        : "Y"     #String for address Y
sc_minus    : "-"     #Manipulated string for signed rotary minus
strnat     : "NAT"   #String for address NAT
sg81       : "G81"    #String for address G81
sg82       : "G82"    #String for address G82
sg80       : "G80"    #String for address G80
strsb      : "SB="    #String for address SB=

#Tool note
stinsert    : "INSERT - " #String for tool notes
stinsert2 : ""               #String for tool notes
stholder    : "HOLDER - " #String for tool notes
stholder2 : ""               #String for tool notes
snocomm     : "DEFINE TOOL NAMES"

#Misc Strings
scomm_str   : "("
scomm_end   : ")"
snull       : ""      # Null character string

#String definitions
sg50        : "G50"   #String for spindle clamp and work coordinate

#Cantext string definitions (spaces must be padded here)
sm00        : "M00"   #String for stop
sm01        : "M01"   #String for optional stop
strtextno : ""           #String for cantext
strcantext : ""          #String for cantext

sblank : ""              #Empty string
sw_string : ""           #String for lathe turret type settings
# --------------------------------------------------------------------------
# Error message strings
# --------------------------------------------------------------------------
sthrderror   : "ERROR: MULTI-START THREAD NOT SUPPORTED WITH LONGHAND FORMAT"
saxiserror  : "ERROR-WRONG AXIS OF ROTATION, ROTATE ON X AXIS OF WCS"
sindxerror  : "WARNING-INDEX ANGLE DOES NOT MATCH MACHINE DEF SETTING ('INDEX ANGLE')"
ssignerror  : "WARNING-SIGNED AXIS POSITIONING MOVE OVER 360 DEGREES"
swrkserror  : "WARNING-WORK OFFSET IS CHANGED IN A SUBPROGRAM"
stoperror   : "ERROR-AXIS SUBSTITUTION MUST USE THE TOP TOOLPLANE"
scutterror  : "ERROR-A VALID CUT TYPE WAS NOT FOUND, CHECK ROTARY SETTINGS"
sfccerror   : "ERROR-MATCHING G70 FINISH PROFILE WAS NOT FOUND"
s5drlerror  : "ERROR-5 AXIS DRILLING REQUIRES LONG CYCLE ('usecan..')"
slthrmerror : "ERROR-ROTATE/MIRROR SUBPROGRAM NOT ALLOWED WITH LATHE PATH"
smilrmerror : "ERROR-ROTATE/MIRROR PROGRAM ROUTINE NOT ALLOWED"
smny50error : "ERROR-G50 AND HOME ('mi1') DOES NOT SUPPORT MULTIPLE TOOL SUBPROGRAM"
shomeserror : "ERROR-HOME ('mi1') DOES NOT SUPPORT TRANSFORM SUBPROGRAM"
symoterror  : "WARNING-Y AXIS MOTION ENCOUNTERED.  NO Y AXIS DEFINED IN MACHINE - CHECK AXIS COMBINATION"
swriteopserror : "ERROR - WRITE NC OPERATION INFORMATION MUST BE ENABLED IN CONTROL DEFINITION - SET AND REPOST"


# --------------------------------------------------------------------------
# Prompt Questions
# --------------------------------------------------------------------------

sask_head1a  : ""
sask_head2a  : ""
sask_head3a  : ""





fq 5 sask_head1a "Enter program number with op, Material Description, Material number" #added 6-02-2020 for kimray standard header information
fq 6 sask_head2a "Enter Print number, revision level, Version number" #added 6-02-2020 for kimray standard header information
fq 7 sask_head3a "Enter Program revision, revision date, revision reason, approved by programmer" #added 6-02-2020 for kimray standard header information





# --------------------------------------------------------------------------
# General G and M Code String select tables
# --------------------------------------------------------------------------
# Strings for switch based on planes, see psw_str_mult
sxg02   : "G2"       #Circular interpolation CW
sxg03   : "G3"       #Circular interpolation CCW
# --------------------------------------------------------------------------
# Motion G code selection
sg00    : "G0"       #Rapid
sg01    : "G1"       #Linear feed
sg02    : "G2"       #Circular interpolation CW
sg03    : "G3"       #Circular interpolation CCW
sg04    : "G4"       #Dwell
sgcode : ""          #Target for string

fstrsel sg00 gcode$ sgcode 5 -1
# --------------------------------------------------------------------------
# Motion G code selection, plane 1
sg00_1  : "G0"       #Rapid
sg01_1  : "G1"       #Linear feed
sg02_1  : "G2"       #Circular interpolation CW
sg03_1  : "G3"       #Circular interpolation CCW
sg04_1  : "G4"       #Dwell
sgcode1 : ""         #Target for string

fstrsel sg00_1 gcode$ sgcode1 5 -1
# --------------------------------------------------------------------------
# Motion G code selection, plane 2
sg00_2  : "G0"       #Rapid
sg01_2  : "G1"       #Linear feed
sg02_2  : "G2"       #Circular interpolation CW
sg03_2  : "G3"       #Circular interpolation CCW
sg04_2  : "G4"       #Dwell
sgcode2 : ""         #Target for string

fstrsel sg00_2 gcode$ sgcode2 5 -1
# --------------------------------------------------------------------------
# Strings for switch based on planes, see psw_str_mult
sxg17   : "G17"      #XY plane code
sxg19   : "G19"      #YZ plane code
sxg18   : "G18"      #XZ plane code
swstr : ""              #Target for string

fstrsel sxg17 rslt_plc swstr 3 -1
# --------------------------------------------------------------------------
# Select work plane G code
sg17    : "G17"      #XY plane code
sg19    : "G19"      #YZ plane code
sg18    : "G18"      #XZ plane code
sgplane : ""            #Target string

fstrsel sg17 plane$ sgplane 3 -1
# --------------------------------------------------------------------------
#Select english/metric code
sg20    : ""   #"G20"      #Inch code
sg21    : ""   #"G21"      #Metric code
smetric : ""         #Target string

fstrsel sg20 met_tool$ smetric 2 -1
# --------------------------------------------------------------------------
sg53    : "G53"      #Machine coordinate reference return
# --------------------------------------------------------------------------
# Strings for switch based on planes, see psw_str_mult
sxg42   : "G41"      #Cutter compensation left
sxg41   : "G42"      #Cutter compensation right
# --------------------------------------------------------------------------
# Cutter compensation G code selection, plane 0
sg40    : "G40"      #Cancel cutter compensation
sg41    : "G41"      #Cutter compensation left
sg42    : "G42"      #Cutter compensation right
sccomp : ""          #Target for string

fstrsel sg40 cc_pos$ sccomp 3 -1
# --------------------------------------------------------------------------
# Cutter compensation G code selection, plane 1
sg40_1  : "G40"      #Cancel cutter compensation
sg41_1  : "G41"      #Cutter compensation left
sg42_1  : "G42"      #Cutter compensation right
sccomp1 : ""         #Target for string

fstrsel sg40_1 cc_pos$ sccomp1 3 -1
# --------------------------------------------------------------------------
# Cutter compensation G code selection, plane 2
sg40_2  : "G40"      #Cancel cutter compensation
sg41_2  : "G41"      #Cutter compensation left
sg42_2  : "G42"      #Cutter compensation right
sccomp2 : ""         #Target for string

fstrsel sg40_2 cc_pos$ sccomp2 3 -1
# --------------------------------------------------------------------------
# Select canned cycle type, profile is direction of finish profile vector
sthdg32 : "G32"      #Cycle type G32
sthdg76 : "G71"      #Cycle type G76
sthdg92 : "G92"      #Cycle type G92
sthdgcode : ""       #Target for string

fstrsel sthdg32 thdtype$ sthdgcode 3 -1
# --------------------------------------------------------------------------
# Select canned cycle type
sg70     : "G87"        #Cycle type G70
sg71     : "G85"        #Cycle type G71
sg72     : "G85"        #Cycle type G72
sg73     : "G86"        #Cycle type G73
sg74     : "G74"        #Cycle type G74
sg75     : "G73"        #Cycle type G75
scclgcode : ""       #Target for string

fstrsel sg70 gcodecc scclgcode 6 -1
# --------------------------------------------------------------------------
# Canned drill cycle string select
sg80_f  : "G181"      #drill face
sg80_fd : "G182"      #drill face w/dwell
sg81_f  : "G183"      #peck face
sg81_fd : "G183"      #peck face w/dwell
sg82_f  : "G183"      #chpbrk face
sg82_fd : "G183"      #chpbrk face w/dwell
sg83_f  : "G178"      #tap right face
sg83_fd : "G184"      #tap left face
sg84_f  : "G85"      #bore1 face
sg84_fd : "G85"      #bore1 face w/dwell
sg85_f  : "G86"      #bore2 face
sg85_fd : "G88"      #bore2 face w/dwell
sg86_f  : "G87"      #misc1 face
sg86_fd : "G87"      #misc1 face w/dwell
sg87_f  : "G8?"      #misc2 face
sg87_fd : "G8?"      #misc2 face w/dwell
sgdrillf : ""        #Target for string

fstrsel sg80_f drlgsel sgdrillf 16 -1
# --------------------------------------------------------------------------
sg80_c  : "G181"      #drill cross
sg80_cd : "G182"      #drill cross w/dwell
sg81_c  : "G183"      #peck cross
sg81_cd : "G183"      #peck cross w/dwell
sg82_c  : "G183"      #chpbrk cross
sg82_cd : "G183"      #chpbrk cross w/dwell
sg83_c  : "G184"      #tap right cross
sg83_cd : "G184"      #tap left cross
sg84_c  : "G189"      #bore1 cross
sg84_cd : "G189"      #bore1 cross w/dwell
sg85_c  : "G86"      #bore2 cross
sg85_cd : "G88"      #bore2 cross w/dwell
sg86_c  : "G87"      #misc1 cross
sg86_cd : "G87"      #misc1 cross w/dwell
sg87_c  : "G8?"      #misc2 cross
sg87_cd : "G8?"      #misc2 cross w/dwell
sgdrillc : ""        #Target for string

fstrsel sg80_c drlgsel sgdrillc 16 -1
# --------------------------------------------------------------------------
#Tapping Strings
sm29    : "M29"      #Rigid Tapping
# --------------------------------------------------------------------------
# Select incremental or absolute G code
sg90 : ""    #G90     #Absolute code
sg91 : ""    #G91     #Incremental code
sgabsinc : ""        #Target string

fstrsel sg90 absinc$ sgabsinc 2 -1
# --------------------------------------------------------------------------
# RPM/CSS code selection
sg97    : "G97"      #RPM
sg96    : "G96"      #CSS
sg9697 : ""          #Target for string

fstrsel sg97 css_actv$ sg9697 2 -1
# --------------------------------------------------------------------------
# Feed mode G code selection
sg98    : "G94"      #UPM
sg99    : "G95"      #UPR
sgfeed : ""          #Target for string

fstrsel sg98 ipr_actv$ sgfeed 2 -1
# --------------------------------------------------------------------------
# C axis cycles
sg107   : "G07.1"     #C axis cylindrical interpolation enable
sg108   : "G07.1"     #C axis cylindrical interpolation disable
sg137   : "G137"     #C axis face polar interpolation enable
sg136   : "G136"     #C axis face polar interpolation disable
# --------------------------------------------------------------------------
#Canned drill cycle reference height
sg198 : ""   #G198   #Reference at initht
sg199 : ""   #G199   #Reference at refht
sgdrlref : ""        #Target for string

fstrsel sg198 drillref sgdrlref 2 -1
# --------------------------------------------------------------------------
# Generate string for spindle, lathe main
sm04    : "M04"      # Spindle reverse - no coolant
sm05    : "M05"      # Spindle off     - no coolant
sm03    : "M03"      # Spindle forward - no coolant
sm14    : "M04"      # Spindle reverse - coolant
sm05c   : "M05"      # Spindle off     - coolant
sm13     : "M04"      # Spindle forward - coolant
spindle_l : ""       #Target for string

fstrsel sm04 g_spdir spindle_l 6 -1
# --------------------------------------------------------------------------
# Generate string for spindle, lathe sub
sm04a    : "M04"      # Spindle reverse - no coolant
sm05a    : "M05"      # Spindle off     - no coolant
sm03a    : "M03"      # Spindle forward - no coolant
sm14a    : "M04"      # Spindle reverse - coolant
sm05ca   : "M05"      # Spindle off     - coolant
sm13a    : "M03"      # Spindle forward - coolant
spindle_ls : ""       #Target for string

fstrsel sm04a g_spdir spindle_ls 6 -1
# --------------------------------------------------------------------------
# Generate string for spindle, lathe main and sub synch
sm04b    : "M04"      # Spindle reverse - no coolant
sm05b    : "M05"      # Spindle off     - no coolant
sm03b    : "M03"      # Spindle forward - no coolant
sm14b    : "M04"      # Spindle reverse - coolant
sm05cb   : "M05"      # Spindle off     - coolant
sm13b    : "M03"      # Spindle forward - coolant
spindle_l_synch : ""       #Target for string

fstrsel sm04b g_spdir spindle_l_synch 6 -1
# --------------------------------------------------------------------------
# Coolant M code selection for V9 style coolant
# Note: To enable V9 style coolant, click on the General Machine Parameters icon
#   in the Machine Definition Manager, Coolant tab, enable first check box
#   Output of V9 style coolant commands in this post is controlled by scoolant
sm09    : "M9"       #Coolant Off
sm08    : "M8"       #Coolant Flood
sm08_1  : "M8"       #Coolant Mist
sm08_2  : "M8"       #Coolant Tool
scoolant : ""        #Target for string

fstrsel sm09 coolant$ scoolant 4 -1
# --------------------------------------------------------------------------
# Coolant output code selection for X style coolant
# Note: To enable X style coolant, click on the General Machine Parameters icon
#   in the Machine Definition Manager, Coolant tab, disable first check box
#   Output of X style coolant commands in this post is controlled by pcan, pcan1, & pcan2
scool50    : "M8"                 #Coolant 1 on value
scool51    : "M9"                 #Coolant 1 off value
scool52    : "M7"                 #Coolant 2 on value
scool53    : "M9"                 #Coolant 2 off value
scool54    : "M88"                #Coolant 3 on value
scool55    : "M89"                #Coolant 3 off value
scool56    : "M104(HP Coolant=ON)"    #Coolant 4 on value
scool57    : "M103(HP Coolant=OFF)"   #Coolant 4 off value
scool58    : "M475(Coolant5=ON)"    #Coolant 5 on value
scool59    : "M474(Coolant5=OFF)"   #Coolant 5 off value
scool60    : "M8(Coolant6=ON)"    #Coolant 6 on value
scool61    : "M9(Coolant6=OFF)"   #Coolant 6 off value
scool62    : "M8(Coolant7=ON)"    #Coolant 7 on value
scool63    : "M9(Coolant7=OFF)"   #Coolant 7 off value
scool64    : "M8(Coolant8=ON)"    #Coolant 8 on value
scool65    : "M9(Coolant8=OFF)"   #Coolant 8 off value
scool66    : "M8(Coolant9=ON)"    #Coolant 9 on value
scool67    : "M9(Coolant9=OFF)"   #Coolant 9 off value
scool68    : "M8(Coolant10=ON)"   #Coolant 10 on value
scool69    : "M9(Coolant10=OFF)"  #Coolant 10 off value
scoolantx : ""                    #Target for string

fstrsel scool50 coolantx scoolantx 20 -1

#X coolant has the option - First coolant off command shuts off ALL coolant options
sall_cool_off  : "M9 M103 M474" #Coolant off command output with all_cool_off

# --------------------------------------------------------------------------
# Table rotation direction, index
sindx_cw    : "M22"    #Rotate CW code
sindx_ccw  : "M21"    #Rotate CCW code
sindx_mc    : ""        #Target for string

fstrsel sindx_cw indx_mc sindx_mc 2 -1
# --------------------------------------------------------------------------
# C-Axis direction
sm15       : "M15"   # Rotate CCW code >
sm16       : "M16"   # Rotate CW code  <
sm1516   : ""           # Target for string

fstrsel sm15 m1516_flg sm1516 2 -1
# --------------------------------------------------------------------------
# C axis mode
sm23     : "M110 (ENABLE C)"      #Main C axis enable
sm24     : "M109 (DISABLE C)"      #C axis disable
sm223   : "M223"     #Sub C axis enable
sm224   : "M224"     #Sub C axis disable
# --------------------------------------------------------------------------
# Chuck clamp Commands
smclmp1       : "M83 (CLAMP)"   # Chuck Clamp
smunclmp1   : "M84 (UN CLAMP)"  #Chuck Unclamp
# --------------------------------------------------------------------------
# Tailstock M code selection
sm26    : "M55 (TLSTK RET)"      #Tailstock retracted
sm25    : "M56 (TLSTK ADV)"      #Tailstock engaged
stlstk    : ""          #Target for string

fstrsel sm26 tlstk stlstk 2 -1
# --------------------------------------------------------------------------
# Generate string for spindle, mill
sm52    : "M14 (MILL REV)"      # Spindle reverse - no coolant
sm55    : "M12 (MILL OFF)"      # Spindle off     - no coolant
sm51    : "M13 ( MILL FOR)"      # Spindle forward - no coolant
sm54    : "M14 (MILL REV)"      # Spindle reverse - coolant
sm55c   : "M12 (MILL OFF)"      # Spindle off     - coolant
sm53    : "M13 (MILL FOR)"      # Spindle forward - coolant
spindle_m : ""       #Target for string

fstrsel sm52 g_spdir spindle_m 6 -1
# --------------------------------------------------------------------------
# Chute M code selection
sm73    : "M76 (CHUTE RET)"      #Chute retracted
sm74    : "M77 (CHUTE ADV)"      #Chute engaged
schute : ""          #Target for string

fstrsel sm73 chute schute 2 -1
# --------------------------------------------------------------------------
#Spindle Clamping M-Codes   Main
sm89   : "M147 (CLAMP ON)"      #Clamp On
sm88   : "M147 (BRAKE ON)"      #Brake/Mid-Clamp On
sm90   : "M146 (CLAMP OFF)"      #Clamp Off
smspdl_clmp : ""    #Target String

fstrsel sm89 clamp_code smspdl_clmp 3 -1
# --------------------------------------------------------------------------
#Spindle Clamping M-Codes   Sub
sm189   : "M189"      #Clamp On
sm188   : "M188"      #Brake/Mid-Clamp On
sm190   : "M190"      #Clamp Off
smspdl_clmps : ""    #Target String

fstrsel sm189 clamp_code smspdl_clmps 3 -1
# --------------------------------------------------------------------------
#Spindle Clamping M-Codes   main and sub synch
sm89a   : "M89 M189"     #Clamp On
sm88a   : "M88 M188"     #Brake/Mid-Clamp On
sm90a   : "M90 M190"     #Clamp Off
smspdl_clmp_synch : ""    #Target String

fstrsel sm89a clamp_code smspdl_clmp_synch 3 -1
# --------------------------------------------------------------------------
# Define the Turning gear selection code
flktbl  1       2       # Lookup table definition - table no. - no. entries
        41      0        # Low gear range
        42     623   # Hi gear range

# Define the Milling gear selection code
flktbl  3       2          # Lookup table definition - table no. - no. entries
        241     0          # Low gear range
        242     1600    # Hi gear range

# --------------------------------------------------------------------------
# Define coolant binary value for X style coolant
flktbl  2       20      #Lookup table definition - table no. - no. entries
        1       50      #Coolant 1 on value
        2       51      #Coolant 1 off value
        4       52      #Coolant 2 on value
        8       53      #Coolant 2 off value
        16      54      #Coolant 3 on value
        32      55      #Coolant 3 off value
        64      56      #Coolant 4 on value
        128     57      #Coolant 4 off value
        256     58      #Coolant 5 on value
        512     59      #Coolant 5 off value
        1024    60      #Coolant 6 on value
        2048    61      #Coolant 6 off value
        4096    62      #Coolant 7 on value
        8192    63      #Coolant 7 off value
        16384   64      #Coolant 8 on value
        32768   65      #Coolant 8 off value
        65536   66      #Coolant 9 on value
        131072  67      #Coolant 9 off value
        262144  68      #Coolant 10 on value
        524288  69      #Coolant 10 off value

# --------------------------------------------------------------------------
# Threading output
# --------------------------------------------------------------------------
# Select Cutting Mode
sm32     : "M32"         #See Okuma Manual Section 13 for diagram   DEFAULT
sm33     : "M33"         #See Okuma Manual Section 13 for diagram
sm34     : "M34"         #See Okuma Manual Section 13 for diagram
scutmode : ""            #Target for string

fstrsel sm32 mi8$ scutmode 3 -1
# --------------------------------------------------------------------------
# Select Infeed Mode
sm85     : "M73"        #See Okuma Manual Section 13 for diagram    DEFAULT
sm84     : "M74"        #See Okuma Manual Section 13 for diagram
sm83     : "M75"        #See Okuma Manual Section 13 for diagram
sinfeed : ""            #Target for string

fstrsel sm85 mi9$ sinfeed 3 -1
# --------------------------------------------------------------------------
# Format statements - n=nonmodal, l=leading, t=trailing, i=inc, d=delta
# --------------------------------------------------------------------------
#Default english/metric position format statements
fs2 1   0.7 0.6     #Decimal, absolute, 7 place, default for initialize (:)
fs2 2   0.4 0.3     #Decimal, absolute, 4/3 place
fs2 3   0.4 0.3d    #Decimal, delta, 4/3 place
#Common format statements
fs2 4   1 0 1 0     #Integer, not leading
fs2 5   2 0 2 0l    #Integer, force two leading
fs2 6   3 0 3 0l    #Integer, force three leading
fs2 7   4 0 4 0l    #Integer, force four leading
fs2 8   6 0 6 0l    #Integer, force six leading
fs2 9   0.1 0.1     #Decimal, absolute, 1 place
fs2 10  0.2 0.2     #Decimal, absolute, 2 place
fs2 11  0.3 0.3     #Decimal, absolute, 3 place
fs2 12  0.4 0.4     #Decimal, absolute, 4 place
fs2 13  0.5 0.5     #Decimal, absolute, 5 place
fs2 14  0.3 0.3d    #Decimal, delta, 3 place
fs2 15  0.2 0.1     #Decimal, absolute, 2/1 place
fs2 16  0 4 0 3t    #No decimal, absolute, 4 trailing
#Default english/metric feed format statements
fs2 17  0.2 0.1     #Decimal, absolute, 2/1 place
fs2 18  0.4 0.3     #Decimal, absolute, 4/3 place
fs2 19  0.5 0.4     #Decimal, absolute, 5/4 place
fs2 20  1 0 1 0n    #Integer, forced output
fs2 25  1.4 1.3lt   #Decimal, absolute, 4/3 trailing

# These formats used for 'Date' & 'Time'
fs2 21  2.2 2.2lt    #Decimal, force two leading & two trailing (time2)
fs2 22  2 0 2 0t     #Integer, force trailing                   (hour)
fs2 23  0 2 0 2lt    #Integer, force leading & trailing         (min)

# This format statement is used for sequence number output
# Number of places output is determined by value for "Increment Sequence Number" in CD
# Max depth to the right of the decimal point is set in the fs statement below
fs2 24  0^7 0^7      #Decimal, 7 place, omit decimal if integer value

# --------------------------------------------------------------------------
# Toolchange / NC output Variable Formats
# --------------------------------------------------------------------------
fmt  "T" 7  toolno      #Tool number
fmt  "G" 4  g_wcs       #WCS G address
fmt  "P" 4  p_wcs       #WCS P address
fmt  "S" 4  speed       #Spindle Speed
fmt  "M" 4  gear        #Gear range
fmt  "M" 4  gearm     # Milling Gear Range
fmt  "S" 4  maxss$       #RPM spindle speed
fmt  "TG=" 4 tg_num     #Tool TG= value (tool number)
tg_num = t$
fmt  "OG=" 4 og_num   #Tool offset number
fmt  "PT=" 2 tmac_pt  #TMAC tool number
tmac_pt = t$
fmt  "PS=" 2 tmac_ps  #TMAC section number from misc real 1
fmt  "PM=" 2 tmac_pm  #TMAC motor number from misc real 2

# --------------------------------------------------------------------------
fmt  "N" 24  n$           #Sequence number
fmt  "X" 2  xref        #X referance position output
fmt  "Y" 2  yref        #Y referance position output
fmt  "Z" 2  zref        #Z referance position output
fmt  "X" 2  xabs        #X position output
fmt  "Y" 2  yabs        #Y position output
fmt  "Z" 2  zabs        #Z position output
fmt  "U" 3  xinc        #X position output
fmt  "V" 3  yinc        #Y position output
fmt  "W" 3  zinc        #Z position output
fmt  "C" 11 cabs        #C axis position
fmt  "H" 14 cinc        #C axis position
fmt  "C" 11 cout_a      #C axis position
fmt  "H" 14 cout_i      #C axis position
fmt  "B" 4  indx_out    #Index position
fmt  "I" 3  iout        #Arc center description in X
fmt  "J" 3  jout        #Arc center description in Y
fmt  "K" 3  kout        #Arc center description in Z
fmt  "L" 2  arcrad$      #Arc Radius
fmt  "F" 18 feed        #Feedrate
fmt  "F" 18 dwell$       #Dwell
fmt  "M" 5  cantext$     #Default cantext
fmt  "C" 2  crad        #C axis start radius, G107
# --------------------------------------------------------------------------
#Move comment (pound) to output colon with program numbers
#fmt  "O" 7  progno$      #Program number
fmt  "" 7  progno$      #Program number
fmt  "O" 7  main_prg_no$ #Program number
fmt  "O" 7  sub_prg_no$  #Program number
fmt  "U" 2  sub_trnsx$   #Rotation point
fmt  "V" 2  sub_trnsy$   #Rotation point
fmt  "W" 2  sub_trnsz$   #Rotation point
# --------------------------------------------------------------------------
# Drill output
# --------------------------------------------------------------------------
fmt  "R" 2  refht_a     #Reference height
fmt  "R" 2  refht_i     #Reference height
fmt  "X" 2  initht_x    #Initial height, mapped X
fmt     2   initht_y    #Initial height, mapped Y
fmt  "Z" 2  initht_z    #Initial height, mapped Z
fmt  "X" 2  refht_x     #Reference height, mapped X
fmt     2   refht_y     #Reference height, mapped Y
fmt  "Z" 2  refht_z     #Reference height, mapped Z
fmt  "X" 2  depth_x     #Depth, mapped X
fmt     2   depth_y     #Depth, mapped Y
fmt  "Z" 2  depth_z     #Depth, mapped Z
fmt  "Q" 16  peck1$     #First peck increment (positive)
fmt     2   peck2$      #Second or last peck (positive)
fmt  "R" 2  peckclr$    #Safety distance
fmt     2   retr$       #Retract height
fmt  "Q" 16 shftdrl$    #Fine bore tool shift
fmt  "F" 2  pitch       #Tap pitch (inches per thread)
fmt  "L" 2  l_drill         # G74 L Value
fmt  "D" 2  d_drill       # G74 D Value
fmt  "K" 2  k_drill       # G74 K Value
fmt  "DA=" 2 da_drill  # G74 DA Value
# --------------------------------------------------------------------------
# Thread output
# --------------------------------------------------------------------------
fmt  "P" 2  thddepth$    #Thread height absolute
fmt  "D" 2  thdfirst$    #First depth cut in thread
fmt  "U" 2  thdlast$     #Last depth cut in thread
fmt  "R" 2  thdfinish$   #G76 thread finish allowance
fmt  "R" 3  thdrdlt     #Thread R delta G92 and G76
fmt  "U" 3  thd_dirx    #Incremental X move for G76 mult starts
fmt  "W" 3  thd_dirz    #Incremental Z move for G76 mult starts
fmt  "P" 5  nspring$     #Number of spring cuts
fmt  "L" 11 thdpulloff$ #G76 thread pull off
fmt     5   thdang      #G76 threading angle
fmt  "Q" 4 nstarts$
fmt  "J" 2 j_feed       #G76 Threads per Inch Variable
# --------------------------------------------------------------------------
# Canned cycle output format (do not change order, used by buffer 2)
# --------------------------------------------------------------------------
fmt  "U" 2  depthcc
fmt  "R" 2  clearcc
fmt  "U" 2  xstckcc
fmt  "W" 2  zstckcc
fmt  "R" 4  ncutscc
fmt      2   stepcc
fmt  "NLP"  5   ng70s       #P line number in canned cycle
fmt  "Q" 4  ng70e       #Q line number in canned cycle
fmt  "U" 2  g73x        #Stored offset of canned cycle rough cut G73
fmt  "V" 2  g73y        #Stored offset of canned cycle rough cut G73
fmt "W" 2  g73z        #Stored offset of canned cycle rough cut G73
fmt  "P" 2  grvspcc
fmt  "Q" 2  grvdpcc
# --------------------------------------------------------------------------
fmt "TOOL GROUP "      4   tnote       # Note format
fmt "OFFSET GROUP "    4   toffnote    # Note format
fmt "DIA. - "      1   tldianote   # Note format
fmt  "D" 25 tldia$                # Note format
fmt  "R" 25 tcr$                  # Note format
# --------------------------------------------------------------------------
fmt     4   year2       #Calculated year value
fmt     21  time2       #Capture 24-hour time value into 'time2' variable
fmt     22  hour        #Hour
fmt     23  min         #Minutes
year2 = year$ + 2000

# --------------------------------------------------------------------------
# Parameter information lookup tables, see pparameter
# --------------------------------------------------------------------------
fprmtbl 1 5 #Rough cut parameters
        13343 depthcc
        10407 clearcc
        10202 xstckcc
        10203 zstckcc
        10214 directcc

fprmtbl 2 4 #Finish cut parameters
        13341 ncutscc
        10101 depthcc
        10102 xstckcc
        10103 zstckcc

fprmtbl 3 5 #Groove cut parameters
        13358 stepcc
        13138 directcc
        13352 dopeckcc
        10316 depthcc
        13364 clearcc

fprmtbl 104 4 #Thread cut parameters
        10811 xmaj_thd
        10813 zstrt_thd
        10814 zend_thd
        10819 face_thd

fprmtbl 17000   8   #Table Number, Size - Machine Definition parameter table
        17391   axis_label   #Axis label - 1=X,2=Y,3=Z
        17398   rot_axis_label   #Axis label - 4=A,5=B,C=6,-1=MACRO
        17402   rot_dir      #Rotary direction
        17408   rot_index    #Index or continuous
        17409   rot_angle    #Index step
        17410   rot_type     #Rotary type
        17101   all_cool_off #First coolant off command shuts off ALL coolant options
        17102   v9_coolant   #Use V9 coolant option

# Control Definition Parameters
fprmtbl 18000   1    #Table Number, Size
#       Param   Variable to load value into
        18171   write_ops    #Enable write NC operation information

pprep$          #Pre-process postblock - Allows post instructions after the post is parsed but before the NC and NCI file are opened.
      rd_cd$       #Read CD Parameters
      rd_mch_ent_no$ = 0  #Read only the machine base parameters (use to collect common parameters from CNC_MACHINE_TYPE)
      rd_md$       #Read machine definition parameters
      rd_tlpathgrp$    #rd_params$ was removed, MU00011, op_id$ is not available for rd_prm_op_no$ which is a necessary helper to rd_params$
      bldnxtool$ = one

pparameter$      #Information from parameters
      #"pwrttparam", ~prmcode$, ~sparameter$, e$
      if prmcode$ = 15145, metvals   = rpar(sparameter$,1)
      if prmcode$ = 15346, comp_type = rpar(sparameter$,1)
      if prmcode$ = 20103, stinsert2 = sparameter$
      if prmcode$ = 20110, stholder2 = sparameter$
      if prmcode$ = 10124, g71type = rpar(sparameter$,1)
      result = fprm (abs(lathecc))
      if prmcode$ = 20108, tap_dir = rpar(sparameter$, 1)

# --------------------------------------------------------------------------
pset_mach       #Set post switches by reading machine def parameters
      #Reset variables prior to MD read
      y_axis_mch = no$    #Reset to zero - Set from Axis Combination

      rd_mch_ent_no$ = syncaxis$  #Retrieve machine parameters based on current axis combination - read from .nci G950 line
      rd_md$       #Read machine definition parameters - calls pmachineinfo$

      #We only need these set at toolchange (and start of file).  No need to set them each time a user may call rd_md
      if rot_angle = zero, ctable = one #ctable zero will produce a divide by zero error, so force to one if zero in MD
        else, ctable = rot_angle

# --------------------------------------------------------------------------
# Machine definition and control definition parameter capture:
# --------------------------------------------------------------------------
pmachineinfo$   #Machine information parameters postblock
      #rd_mach is used to call pmachineinfo postblock and read the parameters of the selected axis
      #combination machine entity set in rd_mch_ent_no.
      #rd_cd is used to call pmachineinfo postblock and read the active control definition parameters
      #rd_tlpathgrp is used to call pmachineinfo postblock and read the active toolpath group parameters
      #"-->pmachineinfo", ~prmcode$, "  ", ~sparameter$, e$  #Do not uncomment if being called from pprep$ - see pprep comment

      #Read parameter lookup tables -
      if prmcode$ >= 17000 & prmcode$ < 18000, result = fprm(17000) #Run the parameter table for Machine Definition Parameters
      #Leave lines below commented until you enter values in related lookup tables
      if prmcode$ >= 18000 & prmcode$ < 19000, result = fprm(18000) #Run the parameter table for Control Definition Parameters
      #if prmcode$ >= 19000 & prmcode$ < 19900, result = fprm(19000) #Run the parameter table for Toolpath Group Parameters

      if axis_label = 2, y_axis_mch = yes$    #Y axis in axis combination found
      if rot_axis_label = 6, c_axis_mch = yes$    #C axis in axis combination found

# --------------------------------------------------------------------------
# Tool Comment / Manual Entry Section
# --------------------------------------------------------------------------
ptoolcomment    #Comment for tool
      if tool_info = 1 | tool_info = 3,
        [
        tnote = abs(t$)
        toffnote = tloffno$
        strtool$ = ucase(strtool$)
        stinsert2 = ucase(stinsert2)
        !spaces$
        spaces$ = zero
        scomm_str, *tnote, 32, *toffnote, scomm_end, e$
        if posttype$ = two , # Lathe toolpath operation
          [
          if tool_op$ = 64, # Drill operation
          scomm_str, *strtool$, scomm_end, e$
          else,
          scomm_str, *strtool$,scomm_end, e$
          ]
        else, # Mill toolpath operation
        scomm_str, *strtool$, scomm_end, e$
        spaces$ = prv_spaces$
        ]

pcomment$       #Comment from manual entry (must call pcomment2)
      pcomment2 #Required if doing boolean 'if' logic testing!

pcomment2       #Output Comment from manual entry
      scomm$ = ucase (scomm$)
      !spaces$
      spaces$ = zero
      if gcode$ = 1005, scomm_str, scomm$, scomm_end, e$  #Manual entry - as comment
      if gcode$ = 1006, scomm$, e$                        #Manual entry - as code
      if gcode$ = 1007, scomm_str, scomm$, scomm_end      #Manual entry - as comment with move NO e$
      if gcode$ = 1026, scomm$                            #Manual entry - as code with move NO e$
      if gcode$ = 1008, scomm_str, scomm$, scomm_end, e$  #Operation comment
      if gcode$ = 1054, scomm_str, scomm$, scomm_end, e$  #File Descriptor
#      if toolchng,      ### Blocked this to remove machine name before every tool - JS
        [
        if gcode$ = 1051, scomm_str, scomm$, scomm_end, e$  #Machine name
        if gcode$ = 1052, scomm_str, scomm$, scomm_end, e$  #Group comment
        if gcode$ = 1053, scomm_str, scomm$, scomm_end, e$  #Group name
        ]
      spaces$ = prv_spaces$

# --------------------------------------------------------------------------
# Start of File and Toolchange Setup
# --------------------------------------------------------------------------
ptime           #Convert 24-hour time format into 12-hour AM/PM format
      if time$ >= 13, time2 = (time$ - 12)
      else, time2 = time$
      hour = int(time2), min = frac(time2)
      *hour, ":", *min,
      if time$ > 12, " PM"
      else, " AM"

pheader_custom         #Start of file
      #"%", e$
      !spaces$
      spaces$ = zero
      #*progno$, " ", scomm_str, sprogname$, scomm_end, e$
      #*progno$, e$
      scomm_str,*progno$, scomm_end, e$  # this outputs  program number in Parentheses.
      #scomm_str, sprogname$, scomm_end, e$

      #q5 #line one of standard program header #added 6-02-2020 for kimray standard header information
      #q6 #line two of standard program header #added 6-02-2020 for kimray standard header information
      #q7 #line three of standard program header #added 6-02-2020 for kimray standard header information
      "(", sask_head1a, ")", e$  #added 4-23-2020 for kimray standard header information
      "(", sask_head2a, ")", e$  #added 4-23-2020 for kimray standard header information
      "(", sask_head3a, ")", e$  #added 4-23-2020 for kimray standard header information
      e$
      #scomm_str, "POSTED - ", month$, "-", day$, "-", year$, 32, ptime, scomm_end, e$
      #scomm_str, "DATE=DD-MM-YY - ", date$, " TIME=HH:MM - ", time$, scomm_end, e$ #Date and time output Ex. 12-02-05 15:52
      #scomm_str, "DATE - ", month$, "-", day$, "-", year$, scomm_end, e$  #Date output as month,day,year - Ex. 02-12-05
      #scomm_str, "TIME - ", time$, scomm_end, e$  #24 hour time output - Ex. 15:52
      #scomm_str, "TIME - ", ptime, scomm_end, e$  #12 hour time output 3:52 PM
      spathnc$ = ucase(spathnc$)
      smcname$ = ucase(smcname$)
      stck_matl$ = ucase(stck_matl$)
      snamenc$ = ucase(snamenc$)
      #scomm_str, "MCX FILE - ", *smcpath$, *smcname$, *smcext$, scomm_end, e$
      #scomm_str, "NC FILE - ", *spathnc$, *snamenc$, *sextnc$, scomm_end, e$
      #scomm_str, "MATERIAL - ", *stck_matl$, scomm_end, e$
      #scomm_str, "POST DEV - ", *slicense, scomm_end, e$
      *e$
      spaces$ = prv_spaces$

lsof0$           #Start of file for tool zero, lathe
      lsof$

lsof$            #Start of file for non-zero tool number, lathe
      sav_cc_1013 = cc_1013$                                   # 1/17/03
      n$, *e$
      n$, "M90", e$
      n$, "M941(A.INT OPEN)", e$    #### ADDED 5-14-19 KIMRAY
      n$, "(CALL OSLTR PHED=1)", e$
      n$, "CLEAR", e$
      n$, "DRAW", e$
      n$,"", e$
      spaces$ = 0
      n$, "M441 PROC=20 PNUM=",*progno$, e$
      n$, "CALL O9018 PJ=V301" "(CHANGE V301 TO THE PROPER TMAC NUMBER IF NOT RUNNING WITH ROBOT HMI)",e$ # ,sprogname$,"."

      spaces$ = 1
      n$, *e$
     #$$ pbld, n$, *smetric, e$
      ltlchg$

msof0$           #Start of file for tool zero, mill
      msof$

msof$            #Start of file for non-zero tool number, mill
      pbld, n$, *smetric, e$
      n$, *e$
      n$, "CLEAR", e$
      n$, "DRAW", e$
      spaces$ = 0
      n$, "M441 PROC=20 PNUM=",*progno$, e$
      n$, "CALL O9018 PJ=V301" "(CHANGE V301 TO THE PROPER TMAC NUMBER IF NOT RUNNING WITH ROBOT HMI)",e$ # ,sprogname$,"."
      spaces$ = 1
      n$, *e$
      mtlchg$

ltlchg$          #Toolchange, lathe
      *e$
      if mr1$, tmac_ps = mr1$
      else, tmac_ps = one
      if mr2$, tmac_pm = mr2$
      else, tmac_pm = one
      toolchng = one
      gcode$ = zero
      copy_x = vequ(x$)
      pcc_capture   #Capture LCC ends, stop output RLCC
      c_rcc_setup$   #Save original in sav_xa and shift copy_x for LCC comp.
      pcom_moveb    #Get machine position, set inc. from c1_xh
      c_mmlt$        #Position multi-tool sub, sets inc. current if G54...
      ptoolcomment
      comment$
      n$, *e$   # space added for seperation of tools to be more defined and visible to the operators
      if home_type < two, #Toolchange G50/home/reference position
        [
        sav_xh = vequ(copy_x)
        sav_absinc = absinc$
        absinc$ = zero
        start_xh = vequ(xh$)
        pmap_home   #Get home position, xabs
        ps_inc_calc #Set start position, not incremental
        #Toolchange home position
        if home_type = one,
          pbld, n$, *sgcode, pwcs, pfxout, pfyout, pfzout, e$
        else,
          [
          #Toolchange g50 position
          pbld, n$, *sg00, *xref, [if y_axis_mch, *yref], *zref, e$
          if home_type = zero, pbld, n$, *sg50, pfxout, pfyout, pfzout, e$
          ]
        pe_inc_calc #Update previous
        absinc$ = sav_absinc
        copy_x = vequ(sav_xh)
        ]
      else,
        [
        pbld, n$, pwcs, e$
        ]
     toolno = t$ * 100 + zero
     toolno = t$ * 100 + tloffno$
     #$$ toolno = tloffno$, e$ #$$ + t$ + tloffno$ #$$  * 10000   * 100
     if opcode$ = three, og_num = lstation$
     else, og_num = tloffno$
     if og_num > three,
     [
     result = mprint("Error Offset Number Must Be Less Than 3 For OG Value")
     exitpost$
     ]
      if not(synch_flg & tool_op$ = 67),     #Suppress tool output if cutoff during part xfer
        [
        if omitseq$ = 1 & tseqno > 0,
          [
          if tseqno = 2, n$ = t$
          result = nwadrs(strnat, n$)
          pbld, *n$, [if home_type = -1, *sgcode], *tg_num, *og_num, e$  #*toolno, e$
          result = nwadrs(strn, n$)
          ]
        else, pbld, n$, [if home_type = -1, *sgcode], *toolno, e$
        ]
      ipr_actv$ = c1_ipr_actv
      pbld, n$, pfsgplane, pfsgfeed, e$
      if m_axis = three, pcaxis_off_l  #Postblock for lathe transition
      pcom_moveb    #Reset machine position, set inc. from last position
      pcan
      pspindle
      pcssg50
      #Added for 'css_start_rpm' logic (09/05/01)
      if css_actv$,
        [
        if css_start_rpm,
          prpm # Direct RPM startup for programmed CSS
        else, pcss # NO RPM start - just output the CSS
        ]
      else, # Direct RPM was programmed
        [
        prpm # Output programmed RPM
        ]
      sav_absinc = absinc$
      if home_type > one, absinc$ = zero
      pcan1, pbld, n$, *sgcode, pfxout, pyout, pfzout, pscool, strcantext, e$
      if lcc_cc_pos, plcc_cc_pos  #Use sav_xa to position with comp. LCC
      pcom_movea    #Update previous, pcan2
      ps_inc_calc   #Reset current
      absinc$ = sav_absinc
      #Added for 'css_start_rpm' logic (09/05/01)
      if css_start_rpm, pcss # CSS output AFTER a G97S???? RPM spindle startup
      pbld, n$, "CALL O9018", *tmac_pm, *tmac_pt, *tmac_ps, e$
      c_msng$        #Position single-tool sub, sets inc. current if G54...
      toolchng = zero
      plast
      sav_cc_st_seq = n$   #saved sequence number for canned cycles
      !t$, !tloffno$, !tlngno$

mtlchg$          #Toolchange, mill
      *e$
      if mr2$, tmac_pm = mr2$
      else, tmac_pm = two
      toolchng = one
      gcode$ = zero
      copy_x = vequ(x$)
      pcom_moveb    #Get machine position, set inc. from c1_xh
      c_mmlt$        #Position multi-tool sub, sets inc. current if G54...
      ptoolcomment
      comment$
      if home_type < two, #Toolchange G50/home/reference position
        [
        sav_xh = vequ(copy_x)
        sav_absinc = absinc$
        absinc$ = zero
        start_xh = vequ(xh$)
        pmap_home   #Get home position, xabs
        ps_inc_calc #Set start position, not incremental
        #Toolchange home position
        if home_type = one,
          pbld, n$, *sgcode, pwcs, pfxout, pfyout, pfzout, e$
        else,
          [
          #Toolchange g50 position/reference
          pbld, n$, *sg00, *xref, [if y_axis_mch, *yref], *zref, e$
          if home_type = zero, pbld, n$, *sg50, pfxout, pfyout, pfzout, e$
          ]
        pe_inc_calc #Update previous
        absinc$ = sav_absinc
        copy_x = vequ(sav_xh)
        ]
      else,
        [
        pbld, n$, pwcs, e$
        ]
      if opcode$ = 3 | opcode$ = 16, toolno = t$ * 100 + tlngno$
      toolno = t$ * 100 + tloffno$
     #$$ else, toolno = t$, e$ #$$+ tloffno$ #$$ * 100
     if opcode$ = three, og_num = lstation$
     else, og_num = tloffno$
      if omitseq$ = 1 & tseqno > 0,
        [
        if tseqno = 2, n$ = t$
        result = nwadrs(strnat, n$)
        pbld, *n$, [if home_type = -1, *sgcode], *tg_num, *og_num, e$  #*toolno, e$
        result = nwadrs(strn, n$)
        ]
      else, pbld, n$, [if home_type = -1, *sgcode], *toolno, e$
      pbld, n$, pfsgplane, pfsgfeed, e$
      pcom_moveb    #Reset machine position, set inc. from last position
      pcaxis_on_m   #Postblock for mill transition
      pbld, n$, "CALL O9018", *tmac_pm, *tmac_pt, *tmac_ps, e$
      m1516_flg = c9k
      prv_m1516_flg = c9k
      pcan
      sav_absinc = absinc$
      if home_type > one, absinc$ = zero
      pbld, n$, pclampoff, e$        # Unclamp
      if millcc,
        [
        cabs = 0
        pbld, n$, *sgcode, pfcout, [if y_axis_mch, "Y0."], e$
        ]
      else,
        [
        prv_gcode$ = c9k                  #change modality for forced output
        pbld, n$, `sgcode, pfcout, e$     #` used in case indexing mode
        ]
      pindex
      if opcode$ <> three, pbld, n$, pclampbrake, e$  # Clamp
      pcan1, pbld, n$, *sgcode, pfxout, pyout, pfzout, pscool, strcantext, e$
      pspindle
      prpm
      pcom_movea    #Update previous, pcan2
      ps_inc_calc   #Reset current
      absinc$ = sav_absinc
      c_msng$        #Position single-tool sub, sets inc. current if G54...
      toolchng = zero
      if millcc, pmillccb #Set mill conversion
      pbld, n$, pfsgplane, e$
      plast
      !t$, !tloffno$, !tlngno$

ltlchg0$         #Call from NCI null tool change, lathe
      toolchng0 = one
      copy_x = vequ(x$)
      start_xh = vequ(xh$)
      c_rcc_setup$   #Save original in sav_xa and shift copy_x for LCC comp.
      pcom_moveb    #Get machine position, set inc. from last position
      c_mmlt$        #Position multi-tool sub, sets inc. current if G54...
      comment$
      pcan

      if t$ = prv_t$ & (tloffno$ <> prv_tloffno$),
      [
      if opcode$ = three, og_num = lstation$
      else, og_num = tloffno$
      pbld, n$, *tg_num, *og_num, e$
      ]

      pbld, n$, psgplane, e$
      pcaxis_off_l  #Postblock for lathe transition
      pspindle
      pnullspindle
      pbld, n$, pscool,e$
      force_flg = 0
      if not(g54g55) & home_type > one & workofs$ <> prv_workofs$, force_flg = 1
      if spindle_no$ <> last_spindle_no, force_flg = 1
      if force_flg,
        [
        sav_absinc = absinc$
        absinc$ = zero
        pbld, n$, pwcs, e$
        pbld, n$, psgcode, pfxout, pfyout, pfzout, e$
        pe_inc_calc #Update previous
        ps_inc_calc #Set current inc.
        absinc$ = sav_absinc
        ]
      #Output cutter comp before each finish pass of           # 1/17/03
      #finishing groove canned cyle                            # 1/17/03
      if gcode$ = one, plinout                                 # 1/17/03
      else,                                                    # 1/17/03
        [                                                      # 1/17/03
        if lathecc = 3, pbld, n$, sccomp, e$                   # 1/17/03
        if tool_op$ = 201, !cc_pos$                            # 5/28/04
        prapidout                                              # 1/17/03
        ]                                                      # 1/17/03
      if lcc_cc_pos, plcc_cc_pos  #Use sav_xa to position with comp. LCC
      pcom_movea
      c_msng$ #Single tool subprogram call
      toolchng0 = zero
      plast
      sav_cc_st_seq = n$   #saved sequence number for canned cycles
      !t$, !tloffno$, !tlngno$

mtlchg0$         #Call from NCI null tool change, mill
      toolchng0 = one
      if last_millcc & op_id$ <> last_op_id & (not(millcc) | cuttype <> last_cuttype), pmillcca #End mill conversion
      copy_x = vequ(x$)
      start_xh = vequ(xh$)
      pcom_moveb    #Get machine position, set inc. from last position
      c_mmlt$        #Position multi-tool sub, sets inc. current if G54...
      comment$
      pcan

      if t$ = prv_t$ & (tloffno$ <> prv_tloffno$),
      [
      if opcode$ = three, og_num = lstation$
      else, og_num = tloffno$
      pbld, n$, *tg_num, *og_num, e$
      ]

      pbld, n$, psgplane, e$
      pcaxis_on_m   #Postblock for mill transition
      pspindle
      pnullspindle
      pbld, n$, pscool,e$
      force_flg = 0
      if not(g54g55) & home_type > one & workofs$ <> prv_workofs$, force_flg = 1
      if spindle_no$ <> last_spindle_no, force_flg = 1
      if force_flg,
        [
        sav_absinc = absinc$
        absinc$ = zero
        pbld, n$, pwcs, e$
        pbld, n$, pclampoff, e$  # Clamp Off
        if millcc & not(last_millcc), pbld, n$, *sgcode, "C0.", [if y_axis_mch, "Y0."], e$
        else,
          [
          prv_gcode$ = c9k                     #change modality for forced output
          pbld, n$, `sgcode, pfcout, e$        #` used in case indexing mode
          ]
        pindex
        pbld, n$, pclampbrake, e$  # Clamp
        pbld, n$, psgcode, pfxout, pfyout, pfzout, e$
        pe_inc_calc #Update previous
        ps_inc_calc #Set current inc.
        absinc$ = sav_absinc
        ]
      else,
        [
        if op_id$ <> last_op_id & millcc & not(last_millcc),
          [
          pbld, n$, pclampoff, e$  # Clamp Off
          cabs = 0
          pbld, n$, *sgcode, pfcout, [if y_axis_mch, "Y0."], e$
          pbld, n$, pclampbrake, e$  # Clamp
          ]
        ]
      pbld, n$, pclampbrake0, e$
      pindex
      ppos_cax_lin  #Position C axis, toolplane or CL
      if millcc,
        [
        pmillccb #Set mill conversion
        pcom_moveb
        ]
      if gcode$ = one, plinout
      else, prapidout
      pbld, n$, pclampbrake, e$
      pcom_movea    #Update previous, pcan2
      c_msng$ #Single tool subprogram call
      toolchng0 = zero
      plast
      !t$, !tloffno$, !tlngno$

plast       #Keep track of previous values
      last_millcc = millcc
      last_op_id =  op_id$
      last_cuttype  = cuttype
      last_spindle_no = spindle_no$

sav_seq       : 0
canneddone    : 0
sav_cc_st_seq : 0   #saved sequence number for canned cycles

pcanneddone
      if omitseq$ = no$ & cc_seqno,    #this is a correction for when sequence numbers are used in lathe to canned cycles, rjj
        [
        if canneddone = one, n$ = ng70e + seqinc$
        if canneddone > one, n$ = sav_seq
        if canneddone > three, canneddone = zero
        if canneddone > zero,
          [
          canneddone = canneddone + one
          ]
        ]
      if tool_op$ < 201 | tool_op$ > 209, canneddone = zero

ptoolend$        #Read from buffer 1 for prv_, current and next tool info
                 #end tool here, current and next valid
      pcanneddone
      if toolend_flg,
        [
        sav_rev = rev #Axis Sub does not update to rev
        pcan
        if n1_gcode <> 1000,
          [
          if millcc, pmillcca #End mill conversion
          toolno = t$ * 100 + zero
          sav_gcode = gcode$
          gcode$ = zero
          if v9_coolant, [coolant$ = zero, pbld, n$, pscool, e$]
          if all_cool_off,
            [
            #all coolant off with a single off code here
            if coolant_on, pbld, n$, *sall_cool_off, e$
            coolant_on = zero
            ]
          else,
            [
            local_int = zero
            coolantx = zero
            while local_int < 20,
              [
              coolantx = and(2^local_int, coolant_on)
              local_int = local_int + one
              if coolantx > zero,
                [
                coolantx = local_int
                pbld, n$, scoolantx, e$
                ]
              coolantx = zero
              ]
            coolant_on = zero
            ]
          if posttype$ = two, pl_retract
          else, pm_retract
          if n1_gcode <> 1003,
            [
            if prog_stop = 1, pbld, n$, *sm01, e$
            if prog_stop = 2, pbld, n$, *sm00, e$
            ]
          gcode$ = sav_gcode
          ]
        else, #Null toolchange
          [
          if n1_posttype <> posttype$, pcan1, pbld, n$, pnullstop, strcantext, e$
          ]
        pcan2
        #Update current variables to prv_ needed in comparisons
        !posttype$
        if rc1 < size1, preadcur_nxt
        ]

      # 1/17/03
      # When canned grooving, set cc_1013 to zero so that the cutter comp
      # value called out on the NCI 1013 line will be ignored.  cc_1013
      # should be restored to it's previous value in 'prcc_call_end'.
      if tool_op$ = 208 | tool_op$ = 62,                         # 1/17/03
        [                                                        # 1/17/03
        sav_cc_1013 = cc_1013$                                   # 1/17/03
        cc_1013$ = zero                                          # 1/17/03
        ]                                                        # 1/17/03

pl_retract      #Retract tool based on next tool gcode, lathe (see ptoolend)
      cc_pos$ = zero
      if home_type = one,
        [
        xh$ = vequ(start_xh)
        pmap_home   #Get home position, xabs
        ps_inc_calc #Set inc.
        pbld, n$, psccomp, e$
        if css_actv$ & css_end_rpm & not(lathe_stop | synch_flg | n1_gcode = 1003 | n1_posttype <> posttype$ | n1_spindle_no <> spindle_no$),
          [
          pspindle
          prpm
          ]
        pcan1, pbld, n$, *sgcode, pfxout, pfyout, pfzout, [if drop_offset, *toolno], strcantext, e$
        if lathe_stop | synch_flg | n1_gcode = 1003 | n1_posttype <> posttype$ | n1_spindle_no <> spindle_no$,
          [
          pbld, n$, pnullstop, e$
          ]
        ]
      else,
        [
        #Retract to reference return
        pbld, n$, `sgcode, psccomp, e$
        if home_type = m_one & drop_offset, pbld, n$, *toolno, e$
        if css_actv$ & css_end_rpm & not(lathe_stop | synch_flg | n1_gcode = 1003 | n1_posttype <> posttype$ | n1_spindle_no <> spindle_no$),
          [
          pspindle
          prpm
          ]
        pbld, n$, "CALL O9018 PM=0", e$
        pcan1, pbld, n$, *sg00, *xref, [if y_axis_mch, *yref], *zref, strcantext, e$
        if lathe_stop | synch_flg | n1_gcode = 1003 | n1_posttype <> posttype$ | n1_spindle_no <> spindle_no$,
          [
          pbld, n$, pnullstop, e$
          ]
        if home_type > m_one & drop_offset, pbld, n$, *toolno, e$
        ]

        prv_g_spdir = m_one      ##rbs_added


pm_retract      #Retract tool based on next tool gcode, mill (see ptoolend)
      pbld, n$, "CALL O9018 PM=0", e$
      if home_type = one,
        [
        xh$ = vequ(start_xh)
        pmap_home   #Get home position, xabs
        if frc_cinit, cabs = zero
        ps_inc_calc #Set inc.
        pbld, n$, psccomp, e$
        if frc_cinit, pbld, n$, pclampoff, e$
        pcan1, pbld, n$, *sgcode, pfxout, pfyout, pfzout, protretinc, [if drop_offset, *toolno], strcantext, e$
        pbld, n$, pnullstop, e$
        ]
      else,
        [
        #Retract to reference return
        pbld, n$, `sgcode, psccomp, e$
        if home_type = m_one & drop_offset, pbld, n$, *toolno, e$
        if frc_cinit, pbld, n$, pclampoff, e$
        pcan1, pbld, n$, *sg00, *xref, [if y_axis_mch, *yref], *zref, protretinc, pnullstop, strcantext, e$
        if home_type > m_one & drop_offset, pbld, n$, *toolno, e$
        ]

protretinc      #Reset the C axis revolution counter
      if frc_cinit,
        [
        rev = zero
        sav_rev = zero
        cabs = zero
        csav = zero
        c_wnd = zero
        prvc_wnd = zero
        indx_out = zero
        if c_axistype = one,
          [
          if home_type = one, pfcout
          else,
            [
            cinc = zero
            *cinc
            ]
          ]
        else,
          [
          pindxcalc
          if c_axistype = three,
            [
            indx_out = cabs
            e$, pbld, n$, pindex
            ]
          else, pfcout
          ]
        !csav, !cabs, !c_wnd
        ]

peof0$           #End of file for tool zero
      peof$

peof$            #End of file for non-zero tool
      ptoolend$
      comment$, e$
      n$, "M940(A.INT CLOSE)", e$
      pbld, n$, "CALL O9018 PG=1.(TMAC RESET)", e$
#      comment$
      n$, "M02", e$
      mergesub$
      clearsub$
      mergeaux$
      clearaux$

pwcs            #G54+ coordinate setting at toolchange
psave_pwcs
      if home_type >= one,
        [
        sav_frc_wcs = force_wcs
        if sub_level$ > 0, force_wcs = zero
        if not(g54g55) & (workofs$ <> prv_workofs$ | (force_wcs & toolchng)),       #Mcam Work Offset Logic
          [
          if sub_level$, result = mprint(swrkserror)
          if workofs$ < 6,
            [
            g_wcs = workofs$ + 54
            *g_wcs
            ]
          else,
            [
            p_wcs = workofs$ - five
            "G54.1", *p_wcs
            ]
          ]
        if g54g55 & (spindle_no$ <> last_spindle_no | (force_wcs & toolchng)),        #G54/G55
          [
          if sub_level$, result = mprint(swrkserror)
          if spindle_no$ = 0, "G54"
          else, "G55"
          ]
        force_wcs = sav_frc_wcs
        !workofs$
        ]

#Rc1 is used to flag the SOF, rc1 = two at SOF
pcaxis_off_l    #Toolchange C axis disable, lathe, check prv_ to current
      if prv_posttype$ <> two & c_axis_mch,
        [
        if synch_flg, pbld, n$, *sm24, *sm224, e$
        else,
          [
          if spindle_no$ = 0, pbld, n$, *sm24, e$
          else, pbld, n$, *sm224, e$
          ]
        ]

pcaxis_on_m     #Toolchange C axis enable, mill, check prv_ to current
      if (rc1 = two | prv_posttype$ = two | spindle_no$ <> last_spindle_no) & c_axis_mch,
        [
        if synch_flg, pbld, n$, *sm23, *sm223, e$
        else,
          [
          if spindle_no$ = 0, pbld, n$, *sm23, e$
          else, pbld, n$,  *sm223, e$
          ]
        #if nextdc$ = three, pbld, n$, "M49", e$  #Disable tap
        ]

plcc_cc_pos     #Position for lathe canned cycle cutter comp. enable
                #Position saved in prcc_setup
      pe_inc_calc   #Update previous
      copy_x = vequ(sav_xa)
      pcom_moveb    #Get machine position, set inc. from previous
      #Force comp from the finish profile
      compok = one
      cc_pos$ = n1_cc_pos
      if gcode$ = zero, prapidout
      else, plinout
      lcc_cc_pos = zero

pgear           #Use spindle gear range, find gear from RPM at X min.
      if use_gear_t = one,
        [
        if lathtype = zero | lathtype = two, x_min$ = c1_x_max
        else, x_min$ = c1_x_min
        x_min$ = x_min$ + c1_tox  #Correction for workshift
        if x_min$ = zero, x_min$ = 0.001
        if css_actv$ = zero, gear_spd = speedrpm
        else, gear_spd = (conversion * g_speed) / (pi$ * abs(x_min$) * two)
        gear = frange(one, gear_spd)
        *gear
        ]

prpm            #Output for start spindle
      speed = speedrpm
      if posttype$ = two,  #Lathe mode spindle
        [
        if speed = zero,
          pbld, n$, pfspindle_l, e$  #RPM = '0', output just an 'M05'
        else,
          [
          if (opcode$ = 3 | opcode$ = 16 | opcode$ = 105) & nextdc$ = 3 & rigid_tap = 1,
            [
            pbld, n$, pgear, e$
            pbld, n$, *sg97, *speed, e$
            ]
          else,
            [
            pbld, n$, pgear, e$
            pbld, n$, *sg97, *speed, [if toolchng, pfspindle_l], e$
            ]
          ]
        ]
      else,    #Milling mode spindle
        [
        result = nwadrs(strsb, speed) #Different letter than 'S' for mill spindle?
        gear_spd = speedrpm
        gearm = frange(3, gear_spd)
        pbld, n$, *speed, [if use_gear_m, *gearm], *spindle_m, e$
        result = nwadrs(strs, speed) #Reset to 'S' for next single speeed output
        ]
      !css_actv$ #Added (8/27/2002)

prpmnull       #Output for RPM at NULL tlchg (don't force spindle 'M' code)
      speed = speedrpm
      if posttype$ = two,
        [
        if (opcode$ = 3 | opcode$ = 16 | opcode$ = 105) & nextdc$ = 3 & rigid_tap = 1,
          [
          pbld, n$, pgear, e$
          pbld, n$, *sg97, e$
          ]
        else,
          [
          pbld, n$, pgear, e$
          pbld, n$, *sg97, *speed, pfspindle_l, e$
          ]
        ]
      else,
        [  #Milling mode spindle
        result = nwadrs(strsb, speed) #Different letter than 'S' for mill spindle?
        if (opcode$ = 3 | opcode$ = 16 | opcode$ = 105) & nextdc$ = 3 & rigid_tap = 1, pbld, n$, *sg97, e$
        else, pbld, n$, *speed, *spindle_m, e$
        result = nwadrs(strs, speed) #Reset to 'S' for next single speeed output
        ]
      !css_actv$ #Added (8/27/2002)

pcssg50         #Output Constant surface speed clamp
      if css_actv$, pbld, n$, *sg50, *maxss$, e$

pcss            #Output Constant surface speed
      speed = g_speed
      if css_actv$,
        [
        if css_start_rpm, pbld, n$, *sg9697, *speed, pspindle_l, !css_actv$, e$
        else, pbld, n$, *sg9697, *speed, pfspindle_l, !css_actv$, e$                 #Force if not called after G97
        ]
      !speed

pspindle_l
      if not(synch_flg),
        [
        if spindle_no$ = 0, spindle_l
        else, spindle_ls
        ]
      else, spindle_l_synch

pfspindle_l
      if not(synch_flg),
        [
        if spindle_no$ = 0, *spindle_l
        else, *spindle_ls
        ]
      else, *spindle_l_synch

#Toolchange setup, spindle output, pspindle must be called first
pnullspindle  #Null toolchange and dwell spindle change, g_speed is input
      if prv_css_actv$<>css_actv$ | prv_g_spdir<>g_spdir | prv_speed<>g_speed,
        [
        #(1/10/2003) - test for coolant OFF (with 'cool_w_spd' mode enabled)
        if posttype$ = two & cool_w_spd <> zero
          & coolant$ = zero & prv_coolant$ > zero, pbld, n$, pscool, e$

        #Switch G97/G96 or direction at null or dwell
        #Stop the spindle if direction changes
        if (prv_g_spdir <> g_spdir) & abs(prv_g_spdir - g_spdir) <> three,
            pbld, n$, pnullstop, e$
        if css_actv$,
          [
          speed = g_speed
          pnullg50
          if prv_speed <> speed | prv_g_spdir<>g_spdir | prv_css_actv$<>css_actv$, pcss #(09/05/01)
          ]
        else,
          [
          if (prv_speed<>g_speed | prv_g_spdir<>g_spdir | prv_css_actv$<>css_actv$)
             & g_speed, prpmnull #(09/05/01)
          ]
        ]
      else, pnullg50

pnullg50      #Change G50 clamp speed at null or dwell
      if prv_maxss$ <> maxss$ & css_actv$, pcssg50

pnullstop     #Stop spindle at null, dwell or tool end
      sav_spdir = g_spdir
      if cool_w_spd = zero, g_spdir = one
      else, g_spdir = one + (fsg2(coolant$) * three)
      if posttype$ = two, pspindle_l
      else, spindle_m
      g_spdir = sav_spdir

pspindle        #Spindle speed calculations for RPM
      if maxss$ = zero | maxss$ > max_speed, maxss$ = max_speed
      if css_actv$,
        [
        #Spindle speed calculations for strt_spd w/CSS
        speedx = abs(xa)
        if opcode$ = 104, speedx = abs(c1_x_min)
        if opcode$ = 105, speedx = abs(tcr$)
        if speedx < 0.001,speedx = 0.001
        speedrpm = (conversion * g_speed) / (pi$ * speedx * two)
        ]
      else, speedrpm = g_speed
      #zero indicates spindle off (not a mistake)
      if speedrpm,
        [
        if speedrpm > maxss$, speedrpm = maxss$
        if speedrpm < min_speed, speedrpm = min_speed
        ]
      #Spindle speed for RPM with lathe drill, thread
      if opcode$ = 104 | opcode$ = 105, css_actv$ = zero
      if css_actv$ = zero, g_speed = speedrpm

pset_g_speed    #Set the spindle control variables from the read variables
      g_speed = abs(ss$)
      if cool_w_spd, g_spdir = fsg3(spdir$) + (fsg2(coolant$) * 3)
      else, g_spdir = fsg3(spdir$)
      if g_speed = zero, g_spdir = one # if RPM = '0', output 'M05'
      if spd_rev, pswtchspin

pswtchspin      #Reverse spindle direction
      if g_spdir > two, g_spdir = abs (g_spdir - five) + three
      else, g_spdir = abs (g_spdir - two)

pclampbrake   #by operation     # clamp_code 0=clamp, 1=brake, 2=off
                                # clamp_flg  0=clamp, 1=brake, 2=off
                                # mi7 - Clamp Code Override
                                #       0 = Default post decision
                                #       1 = Force Full Clamp
                                #       2 = Force Brake / Mid-Clamp
                                #       3 = Off

      #if cuttype = one, pxyzcout0                   #Turning                     off
      #if abs(cuttype) = two                         #Right/Left Face cut         brake unless rotary type is off (0) or Y (3)
      #| abs(cuttype) = three, pxyzcout2             #Cross cut                   brake/clamp
      #if cuttype = four, pxyzcout4                  #Y axis substitution         brake
      #if cuttype = five, pxyzcout5                  #Multisurf Rotary            brake

     if use_clamp | use_brake,
       [
       clamp_code = 2
       if cuttype = 1 | abs(cuttype) = 3 | (abs(cuttype) = 2 & (rotary_type$ = 0 | rotary_type$ = 3) & not(millcc)), clamp_code = 0       #clamp
       if abs(cuttype) = 2 | abs(cuttype) = 3 | cuttype = 4 | cuttype = 5 | millcc,
         [
         if clamp_code <> 0, clamp_code = 1      #brake
         ]
       if opcode$ = 3 | opcode$ = 16, clamp_code = 2
       if use_clamp = 0 & clamp_code = 0, clamp_code = 2
       if use_brake = 0 & clamp_code = 1, clamp_code = 2
       if mi7$, clamp_code = mi7$ - 1
       if synch_flg, smspdl_clmp_synch
       else,
         [
         if spindle_no$ = 0, smspdl_clmp
         if spindle_no$ = 1, smspdl_clmps
         ]
       clamp_flg = clamp_code
       ]

pclampbrake0                     # clamp_code 0=clamp, 1=brake, 2=off
     if (use_clamp | use_brake) & clamp_flg = 0,
        [
        if fmtrnd(cabs) <> prv_cabs, clamp_code = 2
        if mi7$, clamp_code = mi7$ - 1
        if synch_flg, smspdl_clmp_synch
        else,
          [
          if spindle_no$ = 0, smspdl_clmp
          if spindle_no$ = 1, smspdl_clmps
          ]
        clamp_flg = clamp_code
        ]

pfclampon      #Force clamp on
     if use_clamp | use_brake,
       [
       clamp_code = 0
       if mi7$, clamp_code = mi7$ - 1
       if synch_flg, *smspdl_clmp_synch
       else,
         [
         if spindle_no$ = 0, *smspdl_clmp
         if spindle_no$ = 1, *smspdl_clmps
         ]
       clamp_flg = clamp_code
       ]

pfclampoff      #Force clamp off
     if use_clamp | use_brake,
       [
       clamp_code = 2
       if synch_flg, *smspdl_clmp_synch
       else,
         [
         if spindle_no$ = 0, *smspdl_clmp
         if spindle_no$ = 1, *smspdl_clmps
         ]
       clamp_flg = clamp_code
       ]

pclampoff       #Clamp off
     if spindle_no$ <> last_spindle_no, pfclampoff
     if use_clamp | use_brake,
       [
       clamp_code = 2
       if synch_flg, smspdl_clmp_synch
       else,
         [
         if spindle_no$ = 0, smspdl_clmp
         if spindle_no$ = 1, smspdl_clmps
         ]
       clamp_flg = clamp_code
       ]

preadcur_nxt    #Read current and next tool record
      c1_gcode = rbuf (one, rc1)     #Current tool record
      #Place buffered variables in post global variables
      cuttype = c1_cuttype
      lathtype = c1_lathtype
      lathecc = c1_lathecc
      gcodecc = c1_gcodecc
      y_axis = c1_y_axis
      millcc = c1_millcc
      n1_gcode = rbuf (one, nc1)     #Next tool record
      if cuttype = one, cc_1013$ = one
      else, cc_1013$ = zero
      if lathecc<>zero & lathecc<>4, compok = zero
      else, compok = one

ptlchg1002$      #Call at actual toolchange with tlchng_aft
      whatline$ = four #Required for vector toolpaths
      pset_mach   #Set rotary switches by reading machine def parameters
      pmatrix_su
      pmap_plane
      pset_turret
      pset_g_speed
      toolend_flg = one
      if gcode$ = 1000,
        [
        #Null toolchange
        #if millcc & prv_mi4$ = mi4$, cutpos2$ = sav_cutpos2
        if cc_stop_fcc & rcc_flg$ = 6, no_nc_out$ = one
        ]
      else,
        [
        #Toolchange and Start of file
        if gcode$ = 1002,
          [
          #Actual toolchange
          preset_mod
          ]
        prv_xia = vequ (c1_xh)
        prv_feed = c9k
        pnt_at_zero = zero
        ]
      #Mill canned cycle initialze at toolchange
      arcoutput$ = sav_arcout
      if millcc,
        [
        #R arc output
        arcoutput$ = one
        if cuttype = four,
          [
          if g107crad = 0, crad = rotdia$/two
          else, crad = rotdia$
          ]
        else,
          [
          breakarcs$ = zero
          ]
        ]
      iout = zero
      kout = zero
      !mi4$

      if millcc, [
      sg01 = "G101"
      sg02 = "G102"
      sg03 = "G102" ]
      else, [
      sg01 = sg01_1
      sg02 = sg02_1
      sg03 = sg03_1 ]

preset_mod    #Reset the mode flags and map during motion blocks
      breakarcs$ = breakarcss
      cir_at_zero = zero
      linarc$ = zero
      brklinestype$ = zero

# --------------------------------------------------------------------------
# Motion NC output
# --------------------------------------------------------------------------
prapidout       #Output to NC, linear movement - rapid
      pcanneddone
      if interp_flg & (abs(cuttype) = 4 | abs(cuttype) = 2) & cutpos2$ = 0,
        [
        if abs(cuttype) = 4,   #position C then XZ for approach to interpolation on the OD
          [
          pcan1, pbld, n$, psgplane, pexct, psgcode, pcout, pscool, strcantext, e$
          pbld, n$, pexct, pxout, pyout, pzout, e$
          ]
        else,                 #position C and X then Z for approach to interpolation on the face
          [
          pcan1, pbld, n$, psgplane, pexct, psgcode, pxout, pcout, pyout, pscool, strcantext, e$
          pbld, n$, pzout, e$
          ]
        ]
      else,
        [
        pcan1, pbld, n$, psgplane, pexct, psgcode, pxout, pyout,
          pzout, pcout, pscool, strcantext, e$
        ]
      sav_seq = n$

plinout         #Output to NC, linear movement - feed
      #Output the Z after XY so the tool can move to position before plunging
      #helps for toolpaths not starting near the 3o'clock position
      if interp_flg & abs(cuttype) = 2 & cutpos2$ = 0,
        [
        pcan1, pbld, n$, psgplane, psgfeed, pexct, psgcode, psccomp, pxout,
          pyout, pcout, pfr, pscool, strcantext, e$
        pbld, n$, psgfeed, psgcode, pzout, pfr, e$
        ]
      else,
        [
        if opcode$ = 3, pbld, n$, pcout, e$  #Fixes issue with longhand drilling output, cam/wbt
        pcan1, pbld, n$, psgplane, psgfeed, pexct, psgcode, psccomp, pxout,
          pyout, pzout, pcout, pfr, pscool, strcantext, e$
        ]

pcirout   #Output to NC, circular interpolation
      pcan1, pbld, n$, psgplane, psgfeed, pexct, psgcode, psccomp, pxout,
        pyout, pzout, pcout, parc, pfr, pscool, strcantext, e$

pl_ncoutput     #Movement output
      pcc_capture   #Capture LCC ends, stop output RLCC          # 05/28/04   #This was previously commented out but I have removed that as it affects G73 pattern repeat.  I'm not sure what else this affects at this point. WBT
      pcom_moveb    #Get machine position, set inc. from last position
      pcan
      c_rcc_setup$   #Save original in sav_xa and shift copy_x for LCC comp.
      if gcode$ = zero, prapidout
      if gcode$ = one, plinout
      if gcode$ > one & gcode$ < four, pcirout
      if lcc_cc_pos, plcc_cc_pos  #Use sav_xa to position with comp. LCC
      pcom_movea    #Update previous, pcan2

pm_ncoutput     #Movement output
      if millcc, pmillccb #Set mill conversion   #set here so coordinate calc is consitent with state of G137
      pcom_moveb    #Get machine position, set inc. from last position
      pcan
      pindex
      ppos_cax_lin  #Position C axis, toolplane or CL
      if gcode$ = zero, prapidout
      if gcode$ = one, plinout
      if gcode$ > one & gcode$ < four, pcirout
      pcom_movea    #Update previous, pcan2
      ppos_pnt_zero #Update to detect point at zero

pdwl_spd$        #Output to NC, spindle, dwell changes
      pset_g_speed
      pspindle
      comment$
      pnullspindle
      pcan
      if fmtrnd(dwell$), pdwell1
      else, pcan1, pbld, n$, strcantext, e$
      pcan2

mrapid$          #Output to NC of linear movement - rapid, mill
      copy_x = vequ(x$)
      pm_ncoutput

pzrapid$         #Linear movement in Z axis only - rapid, mill
      copy_x = vequ(x$)
      pm_ncoutput

pz$              #Linear movement in Z axis only - at feedrate, mill
      copy_x = vequ(x$)
      pm_ncoutput

mlin$            #Output to NC of linear movement - feed, mill
      copy_x = vequ(x$)
      pm_ncoutput

mcir$            #Output to NC of circular interpolation, mill
      pshft_map_ijk
      copy_x = vequ(x$)
      pm_ncoutput

lrapid$          #Rapid linear movement, lathe
      copy_x = vequ(x$)
      if lathecc = 3, pbld, n$, sccomp, e$        # 1/17/03
      pl_ncoutput

llin$            #Linear line movement - at feedrate, lathe
      copy_x = vequ(x$)
      pl_ncoutput

lcir$            #Circular interpolation, lathe
      pshft_map_ijk
      copy_x = vequ(x$)
      pl_ncoutput

pmx$             #Output to NC of Multisurf Rotary, mill
      copy_x = vequ(x$)
      pm_ncoutput

#Pre-process rotary motion control flags, mill
pmx0$            #5 ax Drill
      if cuttype = five,
        [
        if drill5$ = one, z$ = initht$ * z_mult
        else,
          [
          if fr$ =  -2,gcode$ = zero
          else, gcode$ = one
          ]
        ]
plin0$           #Pre-linear movement postblock
      if posttype$ <> two,
        [
        preset_mod
        if y_axis = zero & millcc = zero & c_axistype <> three,
          [
          #Set brklinestype
          if abs(cuttype) = two & (cutpos2$ >= 2 & cutpos2$ <= 4), brklinestype$ = 6  #Break XY (machine coord sys) motion on during face cut
          if abs(cuttype) = three & (cutpos2$ >= 2 & cutpos2$ <= 4), brklinestype$ = 4  #Break XY (machine coord sys) motion on during cross cut
          #if abs(cuttype) = two, brklinestype$ = 6
          #if cuttype = three, brklinestype$ = four
          ]
        ]

pcir0$           #Pre-circular interpolation postblock
      pmap_plane
      if posttype$ <> two,
        [
        preset_mod
        pshft_map_xc
        if y_axis = zero & millcc = zero,
          [
          #Set linarc, breakarcs and cir_at_zero
          if fmtrnd(xca) = zero & fmtrnd(yca) = zero,
            [
            #Set breakarcs and cir_at_zero
            #if rot_type = 2 & abs(cuttype) = 2, breakarcs$ = 1
            #we want all arcs about X0Y0 to be broken regardless of rot_type
            #This helps with side plane, rotary axis one, full arcs when arcs get converted to rotary motion
            if abs(cuttype) = 2, breakarcs$ = 2      #this can be changed between 1 (quadrants) and 2 (180 deg)
            else, breakarcs$ = zero
            #C axis move
            if mach_plane = zero,
              [
              cir_at_zero = one
              czero_csav = csav
              ]
            #Arc output
            if mach_plane = two, cir_at_zero = m_one
            ]
          if cir_at_zero = zero, linarc$ = one
          ]
        if millcc & plane$ <> 0, linarc$ = one
        ]
      !ynci$

# --------------------------------------------------------------------------
# Motion output components
# --------------------------------------------------------------------------
pdwell1         #Dwell output
      gcode$ = four  #for implied dwells
      pcan1, pbld, n$, *sgcode, *dwell$, strcantext, e$

pbld            #Canned text - block delete
      if bld, '/'

pfbld           #Force block delete
      "/"

psgplane        #Machining plane
      if (gcode$ = 2 | gcode$ = 3) & plane$ <> prv_plane$, result = force(gcode$,gcode$)
      if y_axis_mch & not(millcc) & posttype$ <> 2, sgplane   #plane changes between 0 and 2 for turning, only allow output at toolchange, never allow plane output during G07.1 or G12.1
      !plane$

pfsgplane       #Force machining plane
      if (gcode$ = 2 | gcode$ = 3) & plane$ <> prv_plane$, result = force(gcode$,gcode$)
#      if y_axis_mch | (millcc & cuttype = 4), *sgplane    #force plane output before G07 whether Y-axis or not, never allow plane output during G07.1 or G12.1
       *sgplane
      !plane$

psgfeed
      if posttype$ = 1 & feed < 0.1,ipr_actv$ = 1
      if (opcode$ = 3 | opcode$ = 16 | opcode$ = 105) & nextdc$ = 3,
        [
        if use_pitch = 1, ipr_actv$ = 1
        else, ipr_actv$ = 0
        ]
      sgfeed

pfsgfeed
      if posttype$ = 1 & feed < 0.1,ipr_actv$ = 1
      if (opcode$ = 3 | opcode$ = 16 | opcode$ = 105) & nextdc$ = 3,
        [
        if use_pitch = 1, ipr_actv$ = 1
        else, ipr_actv$ = 0
        ]
      *sgfeed

pexct           #Canned text - exact stop
      if exact, 'G9'

psgcode         #Output the Gcode based on the current plane
      if c_ax_flp,
        [
        #Reverse arc direction for c_axis flip
        if gcode$ = two | gcode$ = three,
          [
          sav_gcode = gcode$
          gcode$ = (5 - gcode$)  #G02->G03 or G03->G02    # 1/17/03
          ]
        ]
      if plane$ = zero, `sgcode
      if plane$ = one, `sgcode1
      if plane$ = two, `sgcode2
      if c_ax_flp, gcode$ = sav_gcode

psccomp         #Output the cutter compensation based on the current plane
      if compok,
        [
        if plane$ = zero, sccomp
        if plane$ = one, sccomp1
        if plane$ = two, sccomp2
        ]

pfxout          #Force X axis output
      if absinc$ = zero, *xabs, !xinc
      else, *xinc, !xabs

pxout           #X output
      if absinc$ = zero, xabs, !xinc
      else, xinc, !xabs

pfyout          #Force Y axis output
      if y_axis_mch,                    #Allow Y in the force out so it can come out before and after G137
        [
        if absinc$ = zero, *yabs
        else, *yinc
        ]
      if not(y_axis_mch), pchecky
      !yabs, !yinc

pyout           #Y output
      if y_axis_mch & not(millcc),
        [
        if absinc$ = zero, yabs
        else, yinc
        ]
      if not(y_axis_mch), pchecky
      !yabs, !yinc

pchecky         #Y output should not happen on a c-axis lathe
      if not(toolchng) & yinc & checkyflg,
        [
        result = mprint(symoterror, 2)
        checkyflg = no$
        ]
pfzout          #Force Z axis output
      if absinc$ = zero, *zabs, !zinc
      else, *zinc, !zabs

pzout           #Z output
      if absinc$ = zero, zabs, !zinc
      else, zinc, !zabs

pfcout          #Force C axis output
      if spindle_no$ = 0,                       #main
        [
        result = nwadrs(strc,cout_a)
        result = nwadrs(strh,cout_i)
        if gcode$ & millcc & g137address = 0, result = nwadrs(stry, cabs)
        if gcode$ & millcc & g137address = 1, result = nwadrs(strc, cabs)
        ]
       else,                                   #sub
        [
        result = nwadrs(stra,cout_a)
        if millcc & g137address = 0, result = nwadrs(stry, cabs)
        if millcc & g137address = 1, result = nwadrs(stra, cabs)
        ]

      cout_a = cabs
      cout_i = cinc
      #cout_i = csav - prv_csav

      if rot_type = 2,
        [
        while cout_a >= 360, cout_a = cout_a - 360
        while cout_a < 0, cout_a = cout_a + 360
        ]

       if fmtrnd(cinc) = 0, m1516_flg = c9k
       if fmtrnd(cinc) > 0, m1516_flg = 0
       if fmtrnd(cinc) < 0, m1516_flg = 1

      if posttype$ <> two & c_axistype < three,
        [
        if c_axistype = one | millcc,
          [
          if (abs(cuttype) = 3 | cuttype = 4) & rot_type = 2,
            [
            if absinc$ = one | (abs(fmtrnd(csav - prv_csav)) >= 180. & gcode$ <> 0), *cout_i, !cinc, !cabs, !cout_a
            else, *cout_a, !cabs, !cinc, !cout_i
            ]
          else,
            [
            if millcc,
              [
              if absinc$ = zero, !cout_a, *cabs, !cinc, !cout_i
              else, !cout_i, *cinc, !cabs, !cout_a
              ]
            else,
              [
              if m1516_flg <> c9k, sm1516, e$
              if absinc$ = zero, *cout_a, !cabs, !cinc, !cout_i
              else, *cout_i, !cinc, !cabs, !cout_a
              ]
            ]
          ]
        else, #Signed direction, modality on c_wnd, no incremental
          [
          if fmtrnd(prv_c_wnd) <> fmtrnd(c_wnd),
            [
            if indx_mc = zero, result = nwadrs(sc_minus, cout_a)
            else, result = nwadrs(str_cax_abs, cout_a)
            *cout_a
            ]
          !c_wnd, !cabs, !cinc
          ]
        ]
      !csav

pcout           #C axis output
      if spindle_no$ = 0,                       #main
        [
        result = nwadrs(strc,cout_a)
        result = nwadrs(strh,cout_i)
        if millcc & g137address = 0, result = nwadrs(stry, cabs)
        if millcc & g137address = 1, result = nwadrs(strc, cabs)
        ]
       else,                                   #sub
        [
        result = nwadrs(stra,cout_a)
        if millcc & g137address = 0, result = nwadrs(stry, cabs)
        if millcc & g137address = 1, result = nwadrs(stra, cabs)
        ]

      cout_a = cabs
      cout_i = cinc
      #cout_i = csav - prv_csav

      if rot_type = 2,
        [
        while cout_a >= 360, cout_a = cout_a - 360
        while cout_a < 0, cout_a = cout_a + 360
        ]

       if fmtrnd(cinc) = 0, m1516_flg = c9k
       if fmtrnd(cinc) > 0, m1516_flg = 0
       if fmtrnd(cinc) < 0, m1516_flg = 1

      if posttype$ <> two & c_axistype < three,
        [
        if c_axistype = one | millcc,
          [
          if (abs(cuttype) = 3 | cuttype = 4) & rot_type = 2,
            [
            if absinc$ = one | (abs(fmtrnd(csav - prv_csav)) >= 180. & gcode$ <> 0), *cout_i, !cinc, !cabs, !cout_a
            else, cout_a, !cabs, !cinc, !cout_i
            ]
          else,
            [
            if millcc,
              [
              if absinc$ = zero, !cout_a, cabs, !cinc, !cout_i
              else, !cout_i, cinc, !cabs, !cout_a
              ]
            else,
              [
              if absinc$ = zero, cout_a, !cabs, !cinc, !cout_i, [if m1516_flg <> c9k, sm1516]
              else, cout_i, !cinc, !cabs, !cout_a, [if m1516_flg <> c9k, sm1516]
              ]
            ]
          ]
        else, #Signed direction, modality on c_wnd, no incremental
          [
          if fmtrnd(prv_c_wnd) <> fmtrnd(c_wnd),
            [
            if indx_mc = zero, result = nwadrs(sc_minus, cout_a)
            else, result = nwadrs(str_cax_abs, cout_a)
            *cout_a
            ]
          !c_wnd, !cabs, !cinc
          ]
        ]
      !csav


pindex          #Index output
      if c_axistype = three,
        [
        pbld, n$, `sindx_mc, indx_out, e$
        !cabs, !cinc
        ]

pindexdrl          #Index output
      if c_axistype = three,
        [
        pbld, n$, `sindx_mc, indx_out
        !cabs, !cinc
        ]

parc            #Select the arc output
      #Setup for arctype setting
      if (posttype$ = 2 & (larctypexz$ = one | larctypexz$ = four)) |
        (posttype$ = 1 &(plane$ = zero & (arctype$ = one | arctype$ = four)) |   #XY Plane
        (plane$ = one & (arctypeyz$ = one | arctypeyz$ = four)) | #YZ Plane
        (plane$ = two & (arctypexz$ = one | arctypexz$ = four))),  #XZ Plane
        [
        result = newfs(two, i$)
        result = newfs(two, j$)
        result = newfs(two, k$)
        result = newfs(two, iout)
        result = newfs(two, jout)
        result = newfs(two, kout)
        ]
      else,
        [
        result = newfs(three, i$)
        result = newfs(three, j$)
        result = newfs(three, k$)
        result = newfs(three, iout)
        result = newfs(three, jout)
        result = newfs(three, kout)
        ]

      if ((posttype$ = 2 & (plane$ = 2 & larctypexz$ < five)) |
        (posttype$ = 1 & ((plane$ = 0 & arctype$ < five) |
        (plane$ = 1 & arctypeyz$ < five) |
        (plane$ = 2 & arctypexz$ < five)))) & not(cuttype = 4 & millcc),
        [
        #Arc output for IJK
        if (posttype$ = 2 & (plane$ = 2 & larctypexz$ = one)) |   #XZ plane - Lathe
          (posttype$ = 1 & ((plane$ = zero & arctype$ = one) |    #XY Plane - Mill
          (plane$ = one & arctypeyz$ = one) |                     #YZ Plane - Mill
          (plane$ = two & arctypexz$ = one))),                    #XZ Plane - Mill
          [
          #Arc output for IJK, absolute
          iout = (iout + dia_shift) * dia_mult
          jout = (jout + y_shift) * y_mult
          kout = (kout + z_shift) * z_mult
          if c_ax_flp, iout = -iout
          ]
        else,
          [
          #Arc output for IJK, start/center
          iout = iout * (dia_mult/abs(dia_mult))
          jout = jout * y_mult
          kout = kout * z_mult
          if c_ax_flp, iout = -iout
          ]
        #If you do NOT want to force out the I,J,K values,
        #remove the "*" asterisks on the *i, *j, *k 's below...
        if plane$ = zero, *iout, *jout, kout #XY plane code - G17
        if plane$ = one, iout, *jout, *kout  #YZ plane code - G19
        if plane$ = two, *iout, jout, *kout  #XZ plane code - G18
        #Original method does not force out IJK values of 0 for delta start to centre arcs
        #iout, kout, jout
        !i$, !j$, !k$
        ]
      else,
        [
        #Arc output for R
        if abs(sweep$)<=180 | cuttype = 4 & millcc |
          (posttype$ = 2 & (plane$ = 2 & larctypexz$ = five)) |               #XZ Plane - Lathe
          (posttype$ = 1 & ((plane$ = 0 & arctype$ = five) |                  #XY Plane - Mill
          (plane$ = 1 & arctypeyz$ = five) |                                  #YZ Plane - Mill
          (plane$ = 2 & arctypexz$ = five))), result = nwadrs(strl, arcrad$)  #XZ Plane - Mill
        else, result = nwadrs(srminus, arcrad$)
        *arcrad$
        ]

pffr            #Output feedrate, force
      if posttype$ = 1 & feed < 0.1,ipr_actv$ = 1
      if ipr_actv$ = zero, pfr_m
      else, pfr_l
      if tap_feed = one & drillcyc$ = three, result = newfs (18, feed)  #Tap feeds with 4/3 decimal places
      *feed

pfr             #Output feedrate
      if posttype$ = 1 & feed < 0.1,ipr_actv$ = 1
      if ipr_actv$ = zero, pfr_m
      else, pfr_l
      if tap_feed = one & drillcyc$ = three, result = newfs (18, feed)  #Tap feeds with 4/3 decimal places
      `feed

pfr_m           #Format feedrate for mill
      result = nwadrs(strf, feed)
      result = newfs (17, feed)

pfr_l           #Format feedrate for lathe
      if opcode$ = 104,
        [
        #Format feedrate for lathe thread
        if thread_address,
          [
          result = nwadrs(stre,feed)
          ]
        else,
          [
          result = nwadrs(strf,feed)             #Default as per Fanuc programming manual
          ]
        result = newfs (19, feed)
        ]
      else,
        [
        result = nwadrs(strf, feed)
        result = newfs (18, feed)
        if feed < 0.1,result = newfs (12, feed)
        ]

pscool          #Coolant is separate code
      if v9_coolant,
        [
        if cool_w_spd = zero, scoolant
        else,
          [ # 'cool_w_spd' mode is active - (1/10/2003)
          if coolant$ = zero, scoolant  #Turn coolant OFF
          ]
        !coolant$
        ]

pfscool         #Coolant is separate code, force
      if v9_coolant,
        [
        if cool_w_spd = zero, *scoolant
        !coolant$
        ]

pcc_capture     #Capture ends of canned turning path, stop output w/rough
      #Stop output in rough only lathe canned cycles
      #between rough and finish paths
      #if cc_stop_fcc & rcc_flg$ = 6, no_nc_out$ = one          # 05/28/04
      if cc_stop_fcc & rcc_flg$ = 6 & lathecc <> 2, no_nc_out$ = one          #wbt - do not want to stop output before/after pattern repeat
      #Capture vector for G73 cycle
      if rpd_typ$ = 6 & abs(lathecc) = two,
        [
        if rcc_flg$ = one, lcc_xcst = vequ (copy_x)
        if rcc_flg$ = three, lcc_xcend = vequ (copy_x)
        ]

pcom_moveb      #Common motion preparation routines, before
      pshft_map_xa
      pxyzcout
      if interp_flg = 1 & millcc,
        [
        #Change rapid to highest possible feedrate
        if gnci$ = zero,
          [
          gcode$ = one
          feed = maxfeedpm
          result = force(feed,feed)
          ]
        ]
      ps_inc_calc

ppos_cax_lin    #Position C if from CL
      if (prv_pnt_at_zero) & c_axistype < three,
        [
        #Output to NC, C axis movement only - rapid deg/min
        sav_gcode = gcode$
        sav_feed = feed
        gcode$ = one
        if millcc = zero,
          [
          feed = maxfrdeg
          pbld, n$, psgcode, pfcout, pffr, e$
          ]
        else, pbld, n$, psgcode, pfcout, pfr, e$
        gcode$ = sav_gcode
        feed = sav_feed
        ]

pcom_movea      #Common motion preparation routines, after
      pcan2
      pe_inc_calc

ppos_pnt_zero   #Position C if from CL
      !pnt_at_zero
      pnt_at_zero = zero

#Mill canned cycle output
pmillccb        #Cross/Face canned cycle code, before
      if interp_flg = 0,
        [
        interp_flg = 1
        result = newfs(two, cabs)
        result = newfs(two, cinc)
        #Cross/Face canned cycle start code
        if abs(cuttype) = two,
          [
          #Face canned cycle start code, G137 (break ramp)
          #Fanuc style uses X diameter, C radius
          pbld, n$, *sg137, "C0.", e$
          prv_xabs = c9k
          prv_xinc = c9k
          prv_cabs = c9k
          prv_cinc = c9k
          compok = one
          ]
        else,
          [
          #Cross canned cycle start code
          #Fanuc Style, G107 is new style, G07.1 is older style
          #Here X is in radius ccords and the toolpath is executed in C (Y coord) and Z
          pbld, n$, pfsgplane, "H0.", *zref, e$
          pbld, n$, *sg107, *crad, e$
          ]
        ]

pmillcca        #Cross/Face canned cycle code, after
      #cancel at end of op only regardless of whether or not the next op
      if interp_flg,
        [
        interp_flg = 0
        #Cross/Face canned cycle end code
        result = newfs(12, cabs)
        result = newfs(14, cinc)
        !cabs
        cabs = 0
        if abs(last_cuttype) = two,   #Face
          [
          #Fanuc Style
          pbld, n$, *sg136, e$
          ]
        else,                         #Cross
          [
          #Fanuc Style
          pbld, n$, *sg108, pfcout, e$
          ]
        cabs = prv_cabs
        ]

# --------------------------------------------------------------------------
# Drilling
# --------------------------------------------------------------------------
pdrill0$         #Pre-drill postblock call
      if cuttype = five, #Don't allow 5 axis, rests at toolchange
        [
        usecandrill$ = zero
        usecanpeck$ = zero
        usecanchip$ = zero
        usecantap$ = zero
        usecanbore1$ = zero
        usecanbore2$ = zero
        usecanmisc1$ = zero
        usecanmisc2$ = zero
        ]
      else,
        [
        if abs(cuttype) < three, mdrl_dir = zero
        else, mdrl_dir = one
        x$ = xnci$
        y$ = ynci$
        z$ = refht$
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        refht_x = vequ(xabs)
        z$ = depth$
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        depth_x = vequ(xabs)
        z$ = zdrl$
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        zdrl_x = vequ(xabs)
        z$ = initht$  #Initial is last
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        initht_x = vequ(xabs)
        znci$ = initht$
        ps_inc_calc
        ]

pdrlcommonb     #Canned Drill Cycle common call, before
      if gcode$ = 81,
        [
        if drillcyc$ = three, drlgsel = fsg1 (-g_speed) + drillcyc$ * two #Tap
        else, drlgsel = fsg2 (dwell$) + drillcyc$ * two
        if initht$ <> refht$, drillref = zero
        else, drillref = one
        prv_refht_a = c9k
        prv_refht_i = c9k
        prv_dwell$ = zero
        ]
      if mdrl_dir = zero, #Set Z to depth
        [
        zia = fmtrnd(depth_z)
        zinc = zia - prv_zia
        ]
      else,               #Set X to depth
        [
        xia = fmtrnd(depth_x)
        xinc = xia - prv_xia
        ]
      xabs = vequ (depth_x)
      comment$
      pcan

pgdrlout        #Drill Gcode output
      if mdrl_dir = zero, *sgdrillf
      else, *sgdrillc

prdrlout        #R drill position
      if posttype$ = one,
      [
      if not(mdrl_dir),
      [   # K Value
      refht_a = abs(initht$ - refht$) #abs(initht$)
      result = nwadrs(strk, refht_a)
      result = nwadrs(strk, refht_i)
      ]
      else,
      [       # I Value
      refht_a = dia_mult * abs(initht$ - refht$)
      result = nwadrs(stri, refht_a)
      result = nwadrs(stri, refht_i)
      ]
      ]
      if absinc$ = zero, refht_a, !refht_i
      else, refht_i, !refht_a

pspdldir      #Test spindle direction for tapping
              if spdir$ > 0, "G77"
              if spdir$ < 0, "G78"

ldrill$          #Canned drill cycle, lathe
      gcode$ = zero
      prv_dwell$ = zero
      @dwell$
      comment$
      pcan
      pe_inc_calc
      xabs = vequ(refht_x)
      ps_inc_calc
      pe_inc_calc
      xabs = vequ(depth_x)
      ps_inc_calc
      result = nwadrs (strk, peck1$)
      k_drill =  refht$# initht$ - refht$
      d_drill = peck1$
      l_drill = d_drill
      da_drill = peckclr$
      n$, sgfeed, e$
      if not(drillcyc$), pcan1, pbld, n$, *sg74, "X0", *depth_z, [if k_drill, *k_drill], "D10.",*feed, dwell$, e$#*d_drill, *l_drill, *feed, dwell$, e$   #[if k_drill, *k_drill]
      if drillcyc$ = one, pcan1, pbld, n$, *sg74, "X0", *depth_z, [if k_drill, *k_drill], *d_drill, *l_drill, *feed, dwell$, e$
      if drillcyc$ = two, pcan1, pbld, n$, *sg74, "X0", *depth_z, [if k_drill, *k_drill], *d_drill, [if peckclr$, *da_drill], *feed, dwell$, e$
      prv_gcode$ =  -1

      if refht$ <> initht$,
        [
        gcode$ = zero
        xabs = vequ(refht_x)
        ps_inc_calc
        pe_inc_calc
        xabs = vequ(initht_x)
        ps_inc_calc
        pbld, n$, sgcode, pfzout, e$
        ]
      pcom_movea

lpeck$           #Canned peck drill cycle, lathe
        ldrill$

lchpbrk$         #Canned chip break cycle, lathe
        ldrill$

ltap$            #Canned tap cycle, lathe
      gcode$ = zero
      prv_dwell$ = zero
      @dwell$
      comment$
      pcan
      pe_inc_calc
      xabs = vequ(refht_x)
      ps_inc_calc
      pe_inc_calc
      xabs = vequ(depth_x)
      ps_inc_calc
      k_drill = initht$ - refht$
      da_drill = peckclr$
      n$, sgfeed, e$
      d_drill = abs(depth_z) + refht$
      l_drill = d_drill
      if tap_dir = 7, n$, "G77",  "X0", *depth_z, *k_drill, *feed, dwell$, e$
      if tap_dir = 8, n$, "G78",  "X0", *depth_z, *k_drill, *feed, dwell$, e$
      prv_gcode$ =  -1
      if refht$ <> initht$,
        [
        gcode$ = zero
        xabs = vequ(refht_x)
        ps_inc_calc
        pe_inc_calc
        xabs = vequ(initht_x)
        ps_inc_calc
        pbld, n$, sgcode, pfzout, e$
        ]
      pcom_movea

lbore1$          #Canned bore #1 cycle, lathe
      ldrill$

lbore2$          #Canned bore #2 cycle, lathe
      ldrill$

lmisc1$          #Canned misc #1 cycle, lathe
      ldrill$

lmisc2$          #Canned misc #2 cycle, lathe
      ldrill$

mdrill$          #Canned drill cycle, mill
      pdrlcommonb
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pfxout, pfyout, pfzout,
        pfcout, pindexdrl, prdrlout, dwell$, pffr, strcantext, "M141", e$
      pcom_movea

mpeck$         #Canned peck drill cycle, mill
      pdrlcommonb
      d_drill = peck1$
      l_drill = d_drill
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pfxout, pfyout, pfzout,
        pfcout, pindexdrl, prdrlout, *d_drill, *l_drill, dwell$, pffr,  strcantext, "M141", e$
      pcom_movea

mchpbrk$       #Canned chip break cycle, mill
      pdrlcommonb
      d_drill = peck1$
      #l_drill = d_drill
      if not(mdrl_dir),[
        l_drill = zabs * -1 + refht$]
        else, [l_drill = (zabs * -1 + refht$) * dia_mult
        ]
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pfxout, pfyout, pfzout,
        pfcout, pindexdrl, prdrlout, *d_drill, *l_drill, dwell$, pffr,  strcantext, "M141", e$
      pcom_movea

mtap$          #Canned tap cycle, mill
      pdrlcommonb
      result = newfs (11, feed)
      #feed = 1
      #j_feed = n_tap_thds$
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pfxout, pfyout, pfzout, pfcout,
      pindexdrl, prdrlout, dwell$, *feed, strcantext, "M141", e$ # *j_feed,
      result = newfs (18, feed)
      pcom_movea

mbore1$        #Canned bore #1 cycle, mill
      mdrill$

mbore2$        #Canned bore #2 cycle, mill
      mdrill$

mmisc1$        #Canned misc #1 cycle, mill
      pdrlcommonb
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pxout, pyout, pzout,
        pcout, pindexdrl, prdrlout, *shftdrl$, dwell$, pffr, strcantext, e$
      pcom_movea

mmisc2$        #Canned misc #2 cycle, mill
      mdrill$

mdrill_2$      #Canned drill cycle repeat, mill
      pdrlcommonb
      pcan1, pbld, n$, pxout, pyout, pzout, pcout, pindexdrl, prdrlout,
      dwell$, pfr, strcantext, [if cinc, "M141"], e$
      pcom_movea

mpeck_2$       #Canned peck drill cycle repeat, mill
      mdrill_2$

mchpbrk_2$     #Canned chip break cycle repeat, mill
      mdrill_2$


mtap_2$        #Canned tap cycle repeat, mill
      pdrlcommonb
      pcan1, pbld, n$, pxout, pyout, pzout, pcout, pindexdrl, prdrlout,
      dwell$, strcantext, [if cinc, "M141"], e$
      pcom_movea

mbore1_2$      #Canned bore #1 cycle repeat, mill
      mdrill_2$

mbore2_2$      #Canned bore #2 cycle repeat, mill
      mdrill_2$

mmisc1_2$      #Canned misc #1 cycle repeat, mill
      mdrill_2$

mmisc2_2$      #Canned misc #2 cycle repeat, mill
      mdrill_2$

pdrlcst$         #Custom drill cycles 8 - 19 (user option)
      #Use this postblock to customize drilling cycles 8 - 19
      pdrlcommonb
      "CUSTOMIZABLE DRILL CYCLE ", pfxout, pfyout, pfzout, pfcout, pindexdrl, e$
      pcom_movea

pdrlcst_2$       #Custom drill cycles 8 - 19 (user option)
      #Use this postblock to customize drilling cycles 8 - 19
      pdrlcommonb
      "CUSTOMIZABLE DRILL CYCLE ", pfxout, pfyout, pfzout, pfcout, pindexdrl, e$
      pcom_movea

pcanceldc$     #Cancel mill drill cycle
      xabs = vequ (initht_x) #Position to return
      ps_inc_calc
      pe_inc_calc #Update to current location
      gcode$ = zero
      pcan
      pcan1, pbld, n$,"G180", strcantext, e$# sgcode, 
      pcan2

pcanceldcl     #Cancel lathe drill cycle
      xabs = vequ (initht_x) #Position to return
      ps_inc_calc
      pe_inc_calc #Update to current location
      gcode$ = zero
      pcan
      pcan1, pbld, n$, sgcode, "G80", strcantext, e$
      pcan2

# --------------------------------------------------------------------------
# MiscOps Section
# --------------------------------------------------------------------------
#Miscellaneous Variables Common to all Miscops operations
#Format as needed

#Integers
#miscops_mi1, miscops_mi2, miscops_mi3,
#miscops_mi4,  miscops_mi5, miscops_mi6,
#miscops_mi7, miscops_mi8, miscops_mi9,
#miscops_mi10

#Reals
#miscops_mr1, miscops_mr2, miscops_mr3,
#miscops_mr4, miscops_mr5, miscops_mr6,
#miscops_mr7, miscops_mr8, miscops_mr9,
#miscops_mr10
#
# --------------------------------------------------------------------------
#Format Assignments and Initializations
# --------------------------------------------------------------------------
fmt "Z" 2 stck_init_z$           #Initial Z position of the stock (900-902,904,905)
fmt "Z" 2 stck_final_z$          #Final Z position of the stock (900-902,904,905)
fmt "Z" 2 stck_chuk_st_z$        #Initial Z axis Chuck Position (900-903)
fmt "X" 2 stck_chuk_st_x$        #Initial X axis Chuck Position (900-903)
fmt "Z" 2 stck_chuk_end_z$       #Final Z axis Chuck Position (900-903)
fmt "X" 2 stck_chuk_end_x$       #Final X axis Chuck Position (900-903)
fmt "B" 3 stck_chuk_st_dz$       #Destination chuck Z axis reference position before transfer (900)
fmt "U" 3 stck_chuk_st_dx$       #Destination chuck X axis reference position before transfer (900)
fmt "B" 3 stck_chuk_end_dz$      #Destination chuck Z axis reference position after transfer (900)
fmt "U" 3 stck_chuk_end_dx$      #Destination chuck X axis reference position after transfer (900)
fmt "Z" 2 stck_clear$            #Stock clearance value for stock pull operation (902)
fmt "X" 2 stck_tool_x$           #Tool X axis position for bar stop / puller (902)
fmt "Z" 2 stck_grip$             #Grip length value for stock pull operation(902)

fmt "F" 18 stck_adv_fr$          #Used with Lathe Stock Advance (Bar-Feed/Pull) function (NCI 902)
fmt "F" 18 stck_appr_fr$         #Used with Lathe Stock Advance (Bar-Feed/Pull) function (NCI 902)

#Flags
stck_op$         : 0             #Stock advance operation method (902)
                                #(0=Push stock,1=Push stock with Use Tool Stop option,2=Pull stock)
stck_spindle$    : 0             #Active spindle with stock to transfer (900-902)
                                #0=Left Spindle,1=Right Spindle
clmp_op$         : 0             #The selected Operation mode: 0=Clamp,1=Un-clamp,2=Re-position (903)
clmp_spindle$    : 0             #Active spindle for clamp/unclamp 0=Left Spindle,1=Right Spindle (903)
tlstck_on$       : 0             #Retract or engage the tailstock (0=Retract,1=Engage) (904)

toolend_flg     : 1             #Flag to execute ptoolend sequence or not
transfer        : 0

fmt "T" 4 miscops_mi1$      #Tool call
fmt "B" 2 miscops_mr1$      #sub rapid point
fmt "B" 2 miscops_mr2$      #sub feed point
fmt "Z" 2 miscops_mr3$      #tool move point

fmt "B" 2 subreturn         #Initial Z axis Chuck Position (900-903)
# --------------------------------------------------------------------------
#Postblock Section -comments only!
# --------------------------------------------------------------------------
pstck_trans$     #NCI code = 900 available variables:
                #stck_spindle, stck_init_z, stck_final_z,
                #stck_chuk_st_z, stck_chuk_st_x,
                #stck_chuk_end_z, stck_chuk_end_x,
                #stck_chuk_st_dz, stck_chuk_st_dx,
                #stck_chuk_end_dz, stck_chuk_end_dx
                if toolchng <> two, ptoolend$
                toolend_flg = zero  #Do not execute ptoolend again after xfer
                [
#                 !spaces$
#                 spaces$ = zero
#                 pbld, n$, "M00",e$
#                 if prv_spaces$ > 0, " ",e$
#                 if stck_spindle$ = 0, "(Xfer Part from Left Spindle)", e$
#                 if stck_spindle$ = 1, "(Xfer Part from Right Spindle)", e$
#                 spaces$ = prv_spaces$
                ]

      !spaces$
      spaces$ = zero

      *e$
      if stck_chuk_st_dz$ = stck_chuk_end_dz$,
       [
       pbld, n$, "(CHUCK RETRACT ONLY)", e$
       transfer = 2
       ]
      else,
       [
       pbld, n$, "(TRANSFER)", e$                #Transfer program
       transfer = 1
       ]

      if transfer = 1,
        [
        toolchng = 1
        pbld, n$, pwcs, e$
        toolchng = 0

        if miscops_mi1$,    #No output of tool or motion if no tool selected
          [
          toolno = miscops_mi1$
          if omitseq$ = 1 & tseqno > 0,
            [
            if tseqno = 2, n$ = int(miscops_mi1$ / 100)
            pbld, *n$, *toolno, "(CUTOFF TOOL, MISC INT 1)", e$
            ]
          else, pbld, n$, *toolno, "(CUTOFF TOOL, MISC INT 1)", e$
          pbld, n$, "G0", *miscops_mr3$, "(TOOL RAPID POSITION, MISC REAL 3)", e$  #MOVE TO POSITION
          ]

        pbld, n$, "(OPEN SUB HERE)", e$

        pbld, n$, "G0", *miscops_mr1$, "(SUB RAPID POSITION, MISC REAL 1)", e$           #sub rapid to position

        if miscops_mi2$,
          [
          pbld, n$, "G1G98", *miscops_mr2$, "(SUB FEED POSITION, MISC REAL 2)", "F50.", e$     #sub feed to position
          pbld, n$, "(TORQUE SKIP MODE ON HERE)", e$    #torque skip
          pbld, n$, "(TORQUE SKIP CODE HERE)G98", *stck_chuk_end_dz$, "F30.", "(SUB PICK-OFF POSITION)", e$     #sub feed to position
          #Usually there's a macro here to check if it's within tolerance of the theoretical position
          ]
        else, pbld, n$, "G1G98", *stck_chuk_end_dz$, "F50.", "(SUB PICK-OFF POSITION)", e$

        pbld, n$, "G4", "U500", e$           #dwell
        pbld, n$, "(CLOSE SUB HERE)", e$              #close sub
        pbld, n$, "G4", "U500", e$            #dwell

        if stck_init_z$ <> stck_final_z$,
          [
          #output this little section if you want motion before the cutoff
          pbld, n$, "(OPEN MAIN HERE)", e$
          pbld, n$, "G4U500", e$  #
          subreturn = (stck_final_z$ - stck_init_z$) + stck_chuk_end_dz$
          pbld, n$, "G1G98", *subreturn, "F50.", "(SUB RETRACT POSITION)", e$  #This could be a G28 or a # macro variable also
          pbld, n$, "(CLOSE MAIN HERE)", e$  #(MAINCLOSE)
          pbld, n$, "G4U500", e$  #
         ]
       ]

           #Cutoff code goes here

      if transfer = 2,
        [
        pbld, n$, "G55", "G0", "B0.", "(SETUP SUB RETURN HOME)", e$    #Assuming G55 and B0 is set at home, this could be a G28 or a # macro variable
        pbld, n$, "M01", e$
        *e$
        ]

      spaces$ = prv_spaces$


pstck_flip$      #NCI code = 901 available variables:
                #stck_spindle, stck_init_z, stck_final_z,
                #stck_chuk_st_z, stck_chuk_st_x,
                #stck_chuk_end_z, stck_chuk_end_x
                if toolchng <> two, ptoolend$
                toolend_flg = zero  #Do not execute ptoolend again after xfer
                [
                 !spaces$
                 spaces$ = zero
                 pbld, n$, "M00",e$
                 if prv_spaces$ > 0, *e$
                 "(Flip Stock)", e$
                 spaces$ = prv_spaces$
                ]

pstck_bar_fd$    #NCI code = 902 available variables:
                #stck_spindle, stck_op, stck_clear,
                #stck_grip, stck_init_z, stck_final_z,
                #stck_chuk_st_z, stck_chuk_st_x,
                #stck_chuk_end_z, stck_chuk_end_x,
                #stck_adv_fr, stck_appr_fr
                if stck_op$ <> 1,  # if NOT using the 'Tool Stop option'
                 [
                  if toolchng <> two, ptoolend$
                  toolend_flg = zero  #Do not execute ptoolend again after xfer
                 ]
                else,
                 toolend_flg = one  #DO execute ptoolend after xfer

                [
                  !spaces$
                  spaces$ = zero
                  pbld, n$, "M00",e$
                  if prv_spaces$ > 0, *e$
                  if stck_op$ = 0, "(Push stock -",e$
                  if stck_op$ = 1, "(Push stock with Use Tool Stop option -",e$
                  if stck_op$ = 2, "(Pull stock -",e$
                  if stck_spindle$ = 0, " from Left Spindle)", e$
                  if stck_spindle$ = 1, " from Right Spindle)", e$
                  spaces$ = prv_spaces$
                ]

pchuck$          #NCI code = 903 available variables:
                #clmp_spindle, clmp_op,  stck_chuk_st_z,
                #stck_chuk_st_x, stck_chuk_end_z, stck_chuk_end_x
                if clmp_op$ = two,
                  [
                  if toolchng <> two, ptoolend$
                  toolend_flg = zero  #Do not execute ptoolend again after xfer
                  ]

                [
                  !spaces$
                  spaces$ = zero
                  pbld, n$, "M00",e$
                  if prv_spaces$ > 0, *e$
                  if clmp_op$ = 0, "(Clamp -",e$
                  if clmp_op$ = 1, "(Un-clamp -",e$
                  if clmp_op$ = 2, "(Re-position -",e$
                  if clmp_spindle$ = 0, " Left Spindle)", e$
                  if clmp_spindle$ = 1, " Right Spindle)", e$
                  spaces$ = prv_spaces$
                ]
                if clmp_op$ >= one, pchuck_unclamp
                if clmp_op$ = two, pbld, n$, *stck_chuk_end_z$, e$
                if clmp_op$ = zero | clmp_op$ = two, pchuck_clamp

pchuck_clamp    #user-defined postblock for chuck clamp
                if clmp_spindle$ = zero, smclmp1, e$
                if clmp_spindle$ = one, "M210", e$

pchuck_unclamp  #user-defined postblock for chuck unclamp
                if clmp_spindle$ = zero, smunclmp1, e$
                if clmp_spindle$ = one, "M211", e$

ptailstock$      #NCI code = 904 available variables:
                #tlstck_on, stck_init_z, stck_final_z
                if toolchng <> two, ptoolend$
                toolend_flg = zero  #Do not execute ptoolend again after xfer
                [
                 !spaces$
                 spaces$ = zero
                 pbld, n$, "M00",e$
                 if prv_spaces$ > 0, *e$
                 if tlstck_on$ = 0, pbld, *sm26, e$
                 if tlstck_on$ = 1, pbld, *sm25, e$
                 spaces$ = prv_spaces$
                ]

psteadyrest$     #NCI code = 905 available variables:
                #stck_init_z, stck_final_z
                if toolchng <> two, ptoolend$
                toolend_flg = zero  #Do not execute ptoolend again after xfer
                [
                 !spaces$
                 spaces$ = zero
                 pbld, n$, "M00",e$
                 if prv_spaces$ > 0, *e$
                 "(Position Steadyrest)", e$
                 spaces$ = prv_spaces$
                ]

# --------------------------------------------------------------------------
# Threading output
# --------------------------------------------------------------------------
pthread0$        #Pre-thread calculations
      if thdtype$ = three,
        [
        thdtype$ = one # Do alternating with 'G71' canned.
        mi8$ = one     # Set for M33 (zigzag thread cutting mode)
        ]

      if nstarts$ > zero & (thdtype$ = zero | thdtype$ = two),
      result = mprint(sthrderror)
      thdrdlt = (thdx3$ - thdx2$)

      # Calculate taper delta 'X' on Acceleration Clearance distance
      thdrdlt = (((thdx3$ - thdx2$) / (thdz1$ - thdz2$)) * thdzclr$)
      # Add to the original thread 'X' difference calculation
      thdrdlt = (thdrdlt + (thdx3$ - thdx2$)) * pl_ax_m0x
      #thdang = rad2deg$ * thdangle$      #lead-in angle
      #thdang = rad2deg$ * thda1$       #half of the thread angle
      thdang = rad2deg$ * thda2$        #thread angle (full included angle)
      thd_dirx = (thdx2$ - thdx3$) * pl_ax_m0x
      thd_dirz = (thdz1$ - thdz2$) * pl_ax_m0z
      thd_vlen = thdlead$/ nstarts$
      thd_dirx = vsa (thd_vlen, thd_dirx)
      nstart_cnt = zero

pthdext$         #Calculation override for external thread
pthdint$         #Calculation override for internal thread
pthdface$        #Calculation override for face thread

pthrg32_1$       # OKUMA... Threading ->
      #-----------------------------------------------------------------------
      # G32 = Fixed threading cycle - Transverse (Face)
      # Format...
      # G32 X Z (A K) F (L,J) C
      #--------------------------------
      # X = X axis end point of thread
      # Z = Z coordinate value of each thread cut
      # K = difference between starting & ending point in Z for tapered thread
      #     (when no 'K' word is programmed, the control assumes K=0.)
      # A = taper angle (referenced to axis parallel to Z axis)
      #     *Thread taper can be specified using either 'K' OR 'A'
      # F = feedrate
      # J = Number of threads within a distance specified by F word.
      #     (when no 'J' word is programmed, the control assumes J=1.)
      # L = Chamfering distance
      #     (when no 'L' word is programmed, the control assumes
      #      L = one lead of thread)
      # C = Phase differrence for multi-start threading
      #     (when no 'C' word is programmed, the control assumes C=0.)
      #     *Multi-start thread is NOT support for this cycle in this post!

      #-----------------------------------------------------------------------
      # G33 = Fixed Thread Cutting Mode - Longitudinal
      #
      # Format...
      # G33 X Z (A I) F (L,J) C
      #--------------------------------
      # X = thread diameter for each thread cut
      # Z = Z axis end point of thread
      # I = difference in radius between starting & ending point for
      #     taper thread (expressed in RADIUS)
      # A = taper angle
      #     *Thread taper can be specified using either 'I' OR 'A'
      # F = feedrate
      # J = Number of threads within a distance specified by F word.
      #     (when no 'J' word is programmed, the control assumes J=1.)
      # L = Chamfering distance
      #     (when no 'L' word is programmed, the control assumes
      #      L = one lead of thread)
      # C = Phase differrence for multi-start threading
      #     (when no 'C' word is programmed, the control assumes C=0.)
      #     *Multi-start thread is NOT support for this cycle in this post!

      #-----------------------------------------------------------------------
      # G34 = Variable lead threading cycle (Increasing Lead)
      # G35 = Variable lead threading cycle (Decreasing Lead)
      # *Variable lead threading is NOT supported...
      #-----------------------------------------------------------------------
      if thdpass$ = one,
        [
        comment$
        gcode$ = zero
        lrapid$
        prv_feed = m_one
        prv_zabs = c9k
        prv_thdtype$ = m_one
        ]

pthrg32_2$       #G32 threading second
      if thdpass$ = one,
        [
        gcode$ = zero
        lrapid$
        ]

pthrg32_3$       #G32 threading third
      copy_x = vequ(x$)
      pcom_moveb
      pbld, n$, sgfeed, e$
      if thdpass$ = one, #State cycle on 1st pass only.
        [
        #Output 'M23' if 'L' Chamfering distance was programmed
        if thdpulloff$, pbld, n$, "M23", e$ # Chamfering ON
        pcan1, pbld, n$, *sthdgcode, pfxout, pfzout, pthdrdlt, pthdpull,
          pffr, strcantext, e$
        ]
      else,
        [
        if thdface$ = one,  #Doing a Face thread
          pbld, n$, pxout, pfzout, e$
        else,
          pbld, n$, pfxout, pzout, e$
        ]
      pcom_movea
      prv_gcode$ = m_one

pthrg32_4$       #G32 threading fourth
      #gcode = zero
      #lrapid

pthrg92_1$       #G92 threading
      pthrg32_1$ #Do the same threading as...

pthrg92_2$       #G92 threading
      pthrg32_2$ #Do the same threading as...

pthrg92_3$       #G92 threading
      pthrg32_3$ #Do the same threading as...

pthrg92_4$       #G92 threading
      pthrg32_4$ #Do the same threading as...

pg32e$           #G32/G92 threading end
        if thdpulloff$, pbld, n$, "M22", e$ # Chamfering OFF
        gcode$ = zero
        lrapid$

pthrg76_1$       #G76 threading start point
      gcode$ = zero
      lrapid$

pg76$  # OKUMA... Threading ->
      # G71 = Threading compound cycle - Longitudinal
      # G72 = Threading compound cycle - Transverse (Face)

      # Format...
      # G71 X Z A I B D U H L E F J M Q
      #--------------------------------
      # X = final diameter of thread
      # Z = Z axis end point of thread
      # I = difference in radius between starting & ending point for
      #     taper thread (expressed in RADIUS)
      # B = infeed angle
      # D = depth of 1st cut (expressed in DIAMETER)
      # U = finishing allowance
      # H = thread height
      # L = chamfering distance in final thread cycle
      #     (effective in M23 mode)
      # E = lead variation rate per lead (variable lead thread)
      # F = feedrate
      # J = same as in G32/G33 modes
      # M = used to select thread cutting pattern and infeed mode
      #     M32 = straight infeed along thread face (left face) *Default*
      #     M33 = zigzag infeed
      #     M34 = straight infeed along thread face (right face)
      #     M73 = Infeed is made by D in each thread cutting cycle until
      #           "H - U (W)" is position is reached.  After that, infeed
      #           is changed to D/2, D/4, D/8, leaving finishing allowance
      #           U(W) if specified.
      #     M74 = Infeed is made by D in each thread cutting cycle until
      #           "H - U (W)" is position is reached.  After that, finish
      #           cycle is made with infeed ammount of U (W).
      #     M75 = Automatic Optimum removal rate (see Okuma OSP manual)
      # Q = number of thread for multi-start thread cutting
      comment$
      gcode$ = one    #### Change one to zero to remove the G0 from in front of z approach--- Rbs
      lrapid$
      sav_xa = vequ(copy_x)
      if thdface$ = one,  #Doing a Face thread
        [
        copy_x = thdz2$  #Ending position in X
        copy_z = thdx2$  #Ending position in Z
        result = nwadrs (strw, thdfinish$) # Finish allowance is 'W' for Face
        ]
      else,
        [
        copy_x = thdx2$  #Ending position in X
        copy_z = thdz2$  #Ending position in Z
        result = nwadrs (stru, thdfinish$)
        #These values expressed as DIAMETERS when NOT doing a Face thread
        thddepth$ = thddepth$ * abs(dia_mult)    #Total Depth (height) of thread
        thdfirst$ = thdfirst$ * abs(dia_mult)    #First depth cut in thread
#        thdfinish$ = thdfinish$ * abs(dia_mult)  #G71 finish allowance
        ]
      pcom_moveb
      if thdpulloff$, pbld, n$, "M23", e$ # Chamfering ON
      #Output the 'G71/G72' threading command block
      j_feed = 1/thdlead$
      pbld, n$, *sthdgcode, pfxout, pfzout, pthdrdlt, *thdang, *thdfirst$,
       pthdfinish, *thddepth$, pthdpull, pg76nstart, pthdMs, "F1.", *j_feed, e$
      pcom_movea
      prv_gcode$ = m_one
      copy_x = vequ(sav_xa)
      pcom_moveb
      pe_inc_calc
      !gcode$, !xabs, !yabs, !zabs, !xinc, !yinc, !zinc
      if thdpulloff$, pbld, n$, "M22", e$ # Chamfering OFF

pthdfinish      #Output 'U' word for taper finishing allowance
      if thdfinish$, *thdfinish$

pthdrdlt        #Output 'I' (or 'K') word for taper thread
      if thdrdlt,
        [
        if thdface$ = zero, #NOT a Face thread
          result = nwadrs(stri, thdrdlt) #use 'I'
        else,
          result = nwadrs(strk, thdrdlt) #use 'K'
        if thdpass$ = one, *thdrdlt # Output only once on 1st pass.
        ]

pg76nstart      #Output 'Q' word for multi-start thread
      if nstarts$ > one, *nstarts$ #Multi-start thread param

pthdpull        #Output 'L' Chamfering distance if programmed
      if thdpulloff$, *thdpulloff$

pthdMs          #Output additional 'M' code for threading
                #Threading Cutting Mode - M32(Default), M33, M34
                #Threading Infeed       - M75(Default), M74, M73
         *scutmode, *sinfeed

# --------------------------------------------------------------------------
# Lathe canned cycle output
# --------------------------------------------------------------------------
pg71         #Output G71-G72 canned cycle routines, old style
      pbld, n$, *scclgcode, *ng70s,  *xstckcc, *zstckcc,   #*ng70e,
        *depthcc, pffr, e$

pg73         #Output G73 canned cycle routines, old style
      pbld, n$, *scclgcode, *ng70s, #*g73x, *g73z, *ng70e,
        *xstckcc, *zstckcc, *depthcc, pffr, e$  #*ncutscc,

pg74         #Output G74-G75 canned cycle routines, old style
      if orient$ = 1, [
        result = nwadrs(strl, clearcc)
        if grvspcc = 0, grvspcc = 1
        if clearcc = 0, clearcc = grvspcc
        pbld, n$, *scclgcode, pfxout, pfzout, *grvspcc, *grvdpcc,
        *clearcc, pffr, e$
        ]
      if orient$ = 5, [
         result = nwadrs (stri, grvspcc)
         result = nwadrs(strd, grvdpcc)
         result = nwadrs(strl, clearcc)
         if grvdpcc = 0, grvdpcc = 1
         if clearcc = 0, clearcc = grvdpcc
         pbld, n$, *scclgcode, pfxout, pfzout, *grvdpcc, *grvspcc,
         *clearcc, pffr, e$
         ]

prcc_setup$      #Lathe canned cycle setup
                #Capture values from rough
      sav_iprcc = c1_ipr_actv
      sav_feedcc = c1_fr_pos
      if orient$ = one|orient$ = two|orient$ = five|orient$ = 6, lccdirx = one
      else, lccdirx = m_one
      if orient$ = one|orient$ = four|orient$ = five|orient$ = 8, lccdirz = one
      else, lccdirz = m_one
      if lathecc > zero, cc_stop_fcc = one
      else, cc_stop_fcc = zero
      #G74/G75
      if lathecc = three,
        [
        lcc_xcst = vequ (copy_x)
        if dopeckcc = zero,
          [
          depthcc = zero
          clearcc = zero
          ]
        if directcc > one,
          [
          gcodecc = four
          grvspcc = stepcc
          grvdpcc = depthcc
          ]
        else,
          [
          gcodecc = five
          grvspcc = depthcc
          grvdpcc = stepcc
          ]
        ]
      else,
        [
        if n1_cc_pos,
          [
          sav_xa = vequ(copy_x)
          #Shift for cutter comp. start position
          copy_x = copy_x + (lcc_move * lccdirx)
          copy_z = copy_z + (lcc_move * lccdirz)
          pcom_moveb
          compok = zero
          lcc_cc_pos = one
          ]
        else, lcc_cc_pos = zero
        ]
      if user_mi10 & tool_op$ = 202 | tool_op$ = 203,     #CRF
        [
        crf_xsav1 = x$
        crf_zsav1 = z$
        ]

prcc_call_st$    #Rough canned cycle start
      if tool_op$ <> 208,
        [
        sav_subout = subout$
        sav_omitsq = omitseq$
        omitseq$ = one
        extprg$ = one
        subout$ = three
        prv_gcode$ = m_one #Added (06/25/01)
        ]

prcc_call_end$   #Rough canned cycle end
      # Restore cc_1013 to the value it held prior to the rough  # 1/17/03
      # groove canned cycle. cc_1013 was changed in ptoolend.    # 1/17/03
      if tool_op$ = 208 | tool_op$ = 62, cc_1013$ = sav_cc_1013     # 1/17/03

      if tool_op$ <> 208,
        [
        omitseq$ = sav_omitsq
        if omitseq$ = no$ & cc_seqno, n$ = sav_cc_st_seq     #reset start of canned cycle sequence number
        #Close the ext file
        result = fclose (sbufname3$)
        #Open the ext file as a buffer
        #Use the size to determine the start and end sequence
        subout$ = sav_subout
        size3 = rbuf(three, zero)
        if omitseq$ = one,
          [
          ng70s = ng70s + seqinc$
          ng70e = n$ + seqinc$
          ]
        else,
          [
          ng70s = n$ + seqinc$
          ng70e = ng70s + (seqinc$ * (size3 - one))
          ]
        pwrite_g70
        ]
      #Setup the stock and clearance directions
      g73x = vsub (lcc_xcst,lcc_xcend)
      g73x = g73x * pl_ax_m0x
      g73z = g73z * pl_ax_m0z
      xstckcc =  abs(xstckcc * dia_mult * lccdirx)
      zstckcc =  zstckcc * lccdirz * pl_ax_m0z
      clearcc =  clearcc * lccdirz * pl_ax_m0z
      #Write the cycle definition
      sav_feed = feed
      sav_ipr = ipr_actv$
      feed = sav_feedcc
      ipr_actv$ = sav_iprcc
      if lathecc = three,
        [
        #Setup the previous position for inc. in G74/G75 cycle
        sav_xa = vequ(xabs) #Save the cycle end
        copy_x = vequ(lcc_xcst) #The cycle start raw
        pshft_map_xa
        pxyzcout  ##The cycle start in machine terms
        ps_inc_calc #Recalculate incremental
        pe_inc_calc #Update previous at start
        xabs = vequ(sav_xa) #Restore the cycle end
        ps_inc_calc #Recalculate incremental
        ]
      if gcodecc = one, depthcc = depthcc * dia_mult #Set depth cuts for diameter
      if gcodecc < three, pg71
      if gcodecc = three, pg73
      if gcodecc > three, pg74
      if lathecc = three,
        [
        #Set the cycle end position at the original start
        copy_x = vequ(lcc_xcst) #The cycle start raw
        pshft_map_xa
        pxyzcout  ##The cycle start in machine terms
        ps_inc_calc #Position at start
        pe_inc_calc #Update previous
        ps_inc_calc #Recalculate incremental
        ]
      feed = sav_feed
      ipr_actv$ = sav_ipr
      if tool_op$ <> 208,
        [
        #Bug2 is off to prevent execution crashes with long strings
        bug2$ = zero
        #Write the cycle profile, sequence are written now
        rc3 = one
        while rc3 <= size3,
          [
          sav_eob = eob$           #save out eob character as it's getting lost
          eob$ = 32                #save out eob character as it's getting lost
          prv_eob$ = 32            #save out eob character as it's getting lost
          #Write the lathe canned cycle profile
          string3 = rbuf (three, rc3)
          if rc3 = two,
            [
            #Add the finish spindle speed to the first move
            speed = n1_ss
            #Mastercam is reporting 0 and 2 backwards for parameter 10124
            #Note that G71 type 1 and 3 are never allowed (can't change Z dir)
            if g71type = 2 | g71type = 3, [
            pbld, *n$, sg82, e$
            pbld, n$, *string3, e$ ]
            if g71type = 1 | g71type = 0, [
            if gcodecc = one, pbld, *ng70s, sg81, e$
            if gcodecc = two, pbld, *ng70s, sg82, e$
            if gcodecc = three, pbld, *ng70s, sg81 , e$
            pbld, n$, *string3, e$ ]
              ]
          else,
            [
            if omitseq$ = one & rc3 = size3 + one,[
            pbld,n$, *string3, e$
            pbld, n$, sg80, e$]
            else, pbld, n$, *string3, e$
            ]
          eob$ = sav_eob          #save out eob character as it's getting lost
          canneddone = one
          ]
        #Close the buffer
        result = fclose (three)
        #Remove the ext file
        result = remove (sbufname3$)
        bug2$ = sav_bug2
        ]
      sav_seq = n$

pfcc_call$       #G70 recall output postblock
      if cc_stop_fcc = zero,
        [
        pread_g70
        if foundcc = zero, result = mprint(sfccerror)
        ]
      no_nc_out$ = zero
      cc_stop_fcc = zero

pread_g70       #Read G70 recall buffer
      foundcc = zero
      size2 = rbuf (two, zero)
      wc2 = one
      while wc2 <= size2 & foundcc = zero,
        [
        fcc_subid = rbuf (two, wc2)
        if fcc_subid = sub_op_id$,
          [
          gcodecc = zero
          ng70s = fcc_ng70s
          ng70e = fcc_ng70e
          pbld, n$, *scclgcode, *ng70s, *ng70e, e$
          foundcc = one
          ]
        ]
      sav_seq = n$
      canneddone = two

pwrite_g70      #Write G70 recall buffer
      fcc_subid = sub_op_id$
      fcc_ng70s = ng70s
      fcc_ng70e = ng70e
      fcc_subid = wbuf (two, rc2)
      if user_mi10 & tool_op$ = 202 | tool_op$ = 203,     #CRF
        [
        #Set the crf_flg to indicate that it's a canned rough and finish
        #Must be set after the output of the N (indicator of the end of the shape) so we can replace the Z coordinate at the right time.
        crf_line = sub_op_id$
        crf_xsav1 = wbuf(4,crf_line)
        prv_xabs = c9k
        ]

# --------------------------------------------------------------------------
#Subprogram output
#sub_trnstyp - 0=mirror, 1=rotate, 2=scale, 3=translate
#sub_trnmthd (mirror) - 0=X axis, 1=Y axis, 2=line
#sub_trnmthd (rotate) - 0=tplane, 1=tplane origin only, 2=coordinates
# --------------------------------------------------------------------------
pmiscint$        #Capture the top level absinc for subprograms
      if sub_level$ <= zero, absinc$ = user_mi2
      synch_flg = mi5$

psub_call_m$     #Call to main level, single tool
      psub_call_trans

psub_call_mm$    #Call to main level, multiple tools
      psub_call_trans

psub_call_trans #Translate level calls from toolchange, user
      #Mirror and coordinate rotate subs not allowed with lathe
      if sub_trnstyp$ <> three & posttype$ = two, result = mprint(slthrmerror)
      if (sub_trnstyp$ = one & sub_trnmthd$ = two)
      | sub_trnstyp$ = zero, result = mprint(smilrmerror)
      sav_absinc = absinc$
      pindex
      if home_type > one,
        [
        if sub_mny_t$,
          [
          absinc$ = zero
          pbld, n$, pwcs, e$
          pbld, n$, *sgcode, pfxout, pfyout, pfzout, pfcout, e$
          pe_inc_calc
          ps_inc_calc
          ]
        ]
      else,
        [
        if home_type = one, result = mprint(shomeserror)
        else,
          [
          if sub_mny_t$, result = mprint(smny50error)
          ]
        #Apply G50 shift and correct incremental position
        if sub_sec_no$ & sub_trnstyp$ = three,
          [
          sub_trnsx$ = vmap(sub_trnsx$, hmtx1)
          sub_trnsx$ = vscl(m_one, sub_trnsx$)
          sub_trnsx$ = sub_trnsx$ * dia_mult
          sub_trnsy$ = sub_trnsy$ * y_mult
          sub_trnsz$ = sub_trnsz$ * z_mult
          pbld, n$, *sg50, *sub_trnsx$, [if y_axis_mch, *sub_trnsy$],
            *sub_trnsz$, e$
          prv_xia = vadd(prv_xia, sub_trnsx$)
          ps_inc_calc
          ]
        if toolchng = zero | home_type < two,
          [
          pbld, n$, *sgcode, pfxout, pfyout, pfzout, pfcout, e$
          pe_inc_calc
          ps_inc_calc
          ]
        ]
      absinc$ = sav_absinc
      result = nwadrs(strp, main_prg_no$)
      pbld, n$, "M98", *main_prg_no$, e$
      result = force(feed,feed) #Force feed in sub

psub_st_m$       #Header in main level
      result = nwadrs(stro, main_prg_no$)
      *e$
      *main_prg_no$, e$

psub_end_m$      #End in main level
      n$, "M99", e$

psub_call_s$     #Call to sub level
      if tool_op$ = 201,  pread_g70
      else, foundcc = zero

      if foundcc = zero,
        [
        result = nwadrs(strp, sub_prg_no$)
        sub_prg_no$ = sub_prg_no$ + 1000 #Add sub number offset
        pbld, n$, "M98", *sub_prg_no$, e$
        ]

psub_st_s$       #Header in sub leveln
      result = nwadrs(stro, sub_prg_no$)
      *e$
      *sub_prg_no$, e$

psub_end_s$      #End in sub level
      n$, "M99", e$

# --------------------------------------------------------------------------
# Canned Text
# --------------------------------------------------------------------------
pcan            #Canned text - before output call
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = zero | cant_pos1$ = three, pcant_1
        if cant_pos2$ = zero | cant_pos2$ = three, pcant_2
        if cant_pos3$ = zero | cant_pos3$ = three, pcant_3
        if cant_pos4$ = zero | cant_pos4$ = three, pcant_4
        if cant_pos5$ = zero | cant_pos5$ = three, pcant_5
        if cant_pos6$ = zero | cant_pos6$ = three, pcant_6
        if cant_pos7$ = zero | cant_pos7$ = three, pcant_7
        if cant_pos8$ = zero | cant_pos8$ = three, pcant_8
        if cant_pos9$ = zero | cant_pos9$ = three, pcant_9
        if cant_pos10$ = zero | cant_pos10$ = three, pcant_10
        if cant_pos11$ = zero | cant_pos11$ = three, pcant_11
        if cant_pos12$ = zero | cant_pos12$ = three, pcant_12
        if cant_pos13$ = zero | cant_pos13$ = three, pcant_13
        if cant_pos14$ = zero | cant_pos14$ = three, pcant_14
        if cant_pos15$ = zero | cant_pos15$ = three, pcant_15
        if cant_pos16$ = zero | cant_pos16$ = three, pcant_16
        if cant_pos17$ = zero | cant_pos17$ = three, pcant_17
        if cant_pos18$ = zero | cant_pos18$ = three, pcant_18
        if cant_pos19$ = zero | cant_pos19$ = three, pcant_19
        if cant_pos20$ = zero | cant_pos20$ = three, pcant_20
        pbld, n$, strcantext, e$
        strcantext = sblank
        ]

pcan1           #Canned text - with move
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = one | cant_pos1$ = four, pcant_1
        if cant_pos2$ = one | cant_pos2$ = four, pcant_2
        if cant_pos3$ = one | cant_pos3$ = four, pcant_3
        if cant_pos4$ = one | cant_pos4$ = four, pcant_4
        if cant_pos5$ = one | cant_pos5$ = four, pcant_5
        if cant_pos6$ = one | cant_pos6$ = four, pcant_6
        if cant_pos7$ = one | cant_pos7$ = four, pcant_7
        if cant_pos8$ = one | cant_pos8$ = four, pcant_8
        if cant_pos9$ = one | cant_pos9$ = four, pcant_9
        if cant_pos10$ = one | cant_pos10$ = four, pcant_10
        if cant_pos11$ = one | cant_pos11$ = four, pcant_11
        if cant_pos12$ = one | cant_pos12$ = four, pcant_12
        if cant_pos13$ = one | cant_pos13$ = four, pcant_13
        if cant_pos14$ = one | cant_pos14$ = four, pcant_14
        if cant_pos15$ = one | cant_pos15$ = four, pcant_15
        if cant_pos16$ = one | cant_pos16$ = four, pcant_16
        if cant_pos17$ = one | cant_pos17$ = four, pcant_17
        if cant_pos18$ = one | cant_pos18$ = four, pcant_18
        if cant_pos19$ = one | cant_pos19$ = four, pcant_19
        if cant_pos20$ = one | cant_pos20$ = four, pcant_20
        ]
      if cstop$, strcantext = strcantext + sm00
      if cgstop$, strcantext = strcantext + sm01
      #Output of strcantext occurs at the end of the output line

pcan2           #Canned text - after output call
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = two | cant_pos1$ = five, pcant_1
        if cant_pos2$ = two | cant_pos2$ = five, pcant_2
        if cant_pos3$ = two | cant_pos3$ = five, pcant_3
        if cant_pos4$ = two | cant_pos4$ = five, pcant_4
        if cant_pos5$ = two | cant_pos5$ = five, pcant_5
        if cant_pos6$ = two | cant_pos6$ = five, pcant_6
        if cant_pos7$ = two | cant_pos7$ = five, pcant_7
        if cant_pos8$ = two | cant_pos8$ = five, pcant_8
        if cant_pos9$ = two | cant_pos9$ = five, pcant_9
        if cant_pos10$ = two | cant_pos10$ = five, pcant_10
        if cant_pos11$ = two | cant_pos11$ = five, pcant_11
        if cant_pos12$ = two | cant_pos12$ = five, pcant_12
        if cant_pos13$ = two | cant_pos13$ = five, pcant_13
        if cant_pos14$ = two | cant_pos14$ = five, pcant_14
        if cant_pos15$ = two | cant_pos15$ = five, pcant_15
        if cant_pos16$ = two | cant_pos16$ = five, pcant_16
        if cant_pos17$ = two | cant_pos17$ = five, pcant_17
        if cant_pos18$ = two | cant_pos18$ = five, pcant_18
        if cant_pos19$ = two | cant_pos19$ = five, pcant_19
        if cant_pos20$ = two | cant_pos20$ = five, pcant_20
        pbld, n$, strcantext, e$
        strcantext = sblank
        ]

pcant_1         #Canned text - output call
      cant_pos = cant_pos1$
      cantext$ = cant_val1$
      pcant_out

pcant_2         #Canned text - output call
      cant_pos = cant_pos2$
      cantext$ = cant_val2$
      pcant_out

pcant_3         #Canned text - output call
      cant_pos = cant_pos3$
      cantext$ = cant_val3$
      pcant_out

pcant_4         #Canned text - output call
      cant_pos = cant_pos4$
      cantext$ = cant_val4$
      pcant_out

pcant_5         #Canned text - output call
      cant_pos = cant_pos5$
      cantext$ = cant_val5$
      pcant_out

pcant_6         #Canned text - output call
      cant_pos = cant_pos6$
      cantext$ = cant_val6$
      pcant_out

pcant_7         #Canned text - output call
      cant_pos = cant_pos7$
      cantext$ = cant_val7$
      pcant_out

pcant_8         #Canned text - output call
      cant_pos = cant_pos8$
      cantext$ = cant_val8$
      pcant_out

pcant_9         #Canned text - output call
      cant_pos = cant_pos9$
      cantext$ = cant_val9$
      pcant_out

pcant_10        #Canned text - output call
      cant_pos = cant_pos10$
      cantext$ = cant_val10$
      pcant_out

pcant_11        #Canned text - output call
      cant_pos = cant_pos11$
      cantext$ = cant_val11$
      pcant_out

pcant_12        #Canned text - output call
      cant_pos = cant_pos12$
      cantext$ = cant_val12$
      pcant_out

pcant_13        #Canned text - output call
      cant_pos = cant_pos13$
      cantext$ = cant_val13$
      pcant_out

pcant_14        #Canned text - output call
      cant_pos = cant_pos14$
      cantext$ = cant_val14$
      pcant_out

pcant_15        #Canned text - output call
      cant_pos = cant_pos15$
      cantext$ = cant_val15$
      pcant_out

pcant_16        #Canned text - output call
      cant_pos = cant_pos16$
      cantext$ = cant_val16$
      pcant_out

pcant_17        #Canned text - output call
      cant_pos = cant_pos17$
      cantext$ = cant_val17$
      pcant_out

pcant_18        #Canned text - output call
      cant_pos = cant_pos18$
      cantext$ = cant_val18$
      pcant_out

pcant_19        #Canned text - output call
      cant_pos = cant_pos19$
      cantext$ = cant_val19$
      pcant_out

pcant_20        #Canned text - output call
      cant_pos = cant_pos20$
      cantext$ = cant_val20$
      pcant_out

pcant_out       #Canned text - build the string for output
      #Assign string select type outputs
      if cant_pos < three, #cant_pos indicates canned text output
        [
        #Assign string select global variables
        if cantext$ = 3, bld = one
        if cantext$ = 4, bld = zero
        if cantext$ = 9, exact = one
        if cantext$ = 10, exact = zero
        #Build the cantext string from strings
        if cantext$ = 1, strcantext = strcantext + sm00
        if cantext$ = 2, strcantext = strcantext + sm01
        #Build the cantext string from string selects
        if cantext$ = 5 | cantext$ = 6,
          [
          if cantext$ = 5, tlstk = zero
          else, tlstk = one
          rslt_upd = updstr (stlstk)
          strcantext = strcantext + stlstk
          ]
        if cantext$ = 7 | cantext$ = 8,
          [
          if cantext$ = 7, chute = zero
          else, chute = one
          rslt_upd = updstr (schute)
          strcantext = strcantext + schute
          ]
        #Build the cantext string from cantext number
        if cantext$ > 10,
          [
          strtextno = no2str(cantext$)
          strcantext = strcantext + strm + strtextno
          ]
        ]
      else, #cant_pos indicates coolant output
        [
        coolant_bin = flook (two, cantext$) #Create binary value for each coolant using lookup table
        if frac(cantext$/two),
          [
          if all_cool_off,
            [
            if coolant_on, pbld, n$, *sall_cool_off, e$
            coolant_on = zero
            suppress = 1               #WBT added this for null toolchange with "First command shuts all off"
                                       #and turn off selected in the second op, post outputs M9 twice
            ]
          else, coolant_on = coolant_on - coolant_bin/2 #Odd = off command, subtract appropriate binary value.
          ]
        else,                                         #Even = on command
          [   #Determine if this coolant is already on
          local_int = zero
          coolantx = zero
          while local_int < 20,
            [
            result2 = and(2^local_int, coolant_on)
            local_int = local_int + one
            if result2 = coolant_bin, suppress = one
            ]
          ]
        if suppress <> 1, #Don't output an on code for a coolant that is already on
          [
          if not(frac(cantext$/two)), coolant_on = coolant_on + coolant_bin #Maintain binary sum of all coolants currently on
          coolantx = cantext$ - 50                                          #Create a coolantx value for string select
          pbld, n$, *scoolantx, e$
          ]
        suppress = zero
        ]

pheader$         #Start of file
      pheader_custom
      if tseqno = 1 & omitseq$ = 1,
        [
        seqno$ = 1
        seqinc$ = 1
        n$ = seqno$
        ]

# --------------------------------------------------------------------------
# Position calculations, generally these do not need to be modified
# --------------------------------------------------------------------------
#The variables for absolute output are xabs, yabs, zabs.
#The variables for incremental output are xinc, yinc, zinc.
#They are found from the input variables x, y, z (typically) which are
#copied to copy_x, copy_y, copy_z.  These are passed to the mapping routine
#to get raw machine coordinates xa, ya, za.  These are used in pxyxcout to
#get the output xabs, yabs, zabs.  ps_inc_calc is called to get xinc, yinc,
#zinc.  cfeed_x, cfeed_y, cfeed_z are the unshifted positions for feed
#calculations.
# --------------------------------------------------------------------------
pxyzcout      #Perform calls for mapping coordinates and shifts
      if posttype$ <> two & y_axis = zero & millcc = zero & fmtrnd(xca) = zero & fmtrnd(yca) = zero & mach_plane = zero, czero_csav = prv_csav
      pplane_mod
      if cuttype = one, pxyzcout0                   #Turning
      if abs(cuttype) = two                         #Right/Left Face cut
      | abs(cuttype) = three, pxyzcout2             #Cross cut
      if cuttype = four, pxyzcout4                  #Y axis substitution
      if cuttype = five, pxyzcout5                  #Multisurf Rotary
      #C axis control modifications
      if posttype$ <> two,
        [
        pcoutrev
        if not(one_rev),   #MU00004
          [
          if rot_dir, cabs = c_wnd * m_one
          else, cabs = c_wnd
          ]
        else,
          [
          if rot_dir, cabs = csav * m_one
          else, cabs = csav
          ]
        if c_axistype > one | millcc,
          [
          pindxcalc
          if c_axistype = three,
            [
            #Check if in tolerance
            cdelta = frac(abs(cabs)/ctable)
            if cdelta > ixtol & cdelta < 1-ixtol,
              [
              result = mprint(sindxerror)
              exitpost$
              ]
            indx_out = cabs
            ]
          if c_axistype = two, #Signed direction calculation
            [
            #Warn if a move greater than 360
            if abs(prvc_wnd - c_wnd) > 360, result = mprint(ssignerror)
            ]
          ]
        if y_axis = zero,
          [
          if cir_at_zero = one, gcode$ = one #only C is moving
          if cir_at_zero = m_one & (xa < zero | prv_xa < zero), c_ax_flp = one
          else, c_ax_flp = zero
          ]
        if millcc,
          [
          if fmtrnd(cabs) = 360, cabs = zero  #Always try to start at zero
          if interp_flg,
            [
            if abs(cuttype) = two, ppolar_fcyc
            ]
          else, xabs = abs(xabs)
          ]
        ]
      pfcalc

pxyzcout0       #Lathe and machine coordinates
      #This portion (tool_op$ = 202/203) is still the roughing cycle,
      #we must replace X and Z at this time (before the spindle call)
      if tool_op$ = 202 | tool_op$ = 203 & gcode$ = 0 & user_mi10 & cutpos2$ = 4,     #CRF
        [
        crf_line = fcc_subid
        size4 = rbuf(4,0)
        if crf_line <= size4, crf_xsav2 = rbuf(4,crf_line)
        if cutpos2$ = 4,       #if it's cutpos2$ = 4 (end of path) we want to add the move to the
          [                    #pre canned cycle position but not replace the move from MP
          cfeed_x = crf_xsav2
          cfeed_z = crf_zsav2
          pax_shift
          prapidout
          ]
        if cutpos2$ = 0,       #Cutpos2$ = 0 is before an op, we want to replace the move from MP at this time
          [
          xa = crf_xsav2
          za = crf_zsav2
          ]
        ]
      #This portion (tool_op$ = 201) is now the finishing cycle,
      #we must replace X and Z at this time so Mastercam's coordinates don't override our work
      if tool_op$ = 201 & gcode$ = 0 & user_mi10,     #CRF
        [
        crf_line = fcc_subid
        size4 = rbuf(4,0)
        if crf_line <= size4, crf_xsav2 = rbuf(4,crf_line)
        xa = crf_xsav2
        za = crf_zsav2
        ]
      cfeed_x = vequ(xa)
      csav = c$
      pax_shift
      ipr_type = zero

pxyzcout4       #Calculations for Y axis substitution (mapped)
      cfeed_x = xa + (rotdia$/two)
      cfeed_y = zero
      cfeed_z = za
      csav = ya * (360 / (pi$ * rotdia$))
      pax_shift
      if millcc, ipr_type = zero
      else, ipr_type = one

pxyzcout2       #Polar conversion, Cross cut, Right/Left Face cut
      #Drill polar is toolplane drilling toward center
      #if not a coincident axis (Face cut)
      if (y_axis | (opcode$ = three & abs(cuttype) <> two)), pxyzcout0
      else,
        [
        cfeed_x = sqrt(xa^2 + ya^2)
        cfeed_y = zero
        cfeed_z = za
        #if opcode$ = three & abs(cuttype) = three, csav = c$
        #else, csav = atan2(ya, xa) + c$
        if opcode$ = three & abs(cuttype) = three, csav = c$
        else,
          [
          if abs(cuttype) = 2, csav = atan2(ya, xa) + c$             #on the face you need to add c$ in case of twisted face plane
          else,
            [
            csav = c$         #cross cutting with rotary turned on (NOT AXIS SUB!)
            cfeed_y = ya      #C only indexes to plane and then Y motion
            ]
          ]
        pax_shift
        ipr_type = one
        if not(millcc & abs(cuttype) = two),
          [
          if fmtrnd(xa) = zero & fmtrnd(ya) = zero & opcode$ <> three,
            pnt_at_zero = one
          ]
        ]

pxyzcout5       #Multisurf rotary axis motion
      #map to machine co-ordinate matrix
      axisx$ = vequ(caxisx)
      vtoolx_rot = rotv(oneeighty,vtoolx$)
      axisx$ = vequ(aaxisx)
      xa = rotp(oneeighty,xa)
      csav = atan2(vtooly_rot, vtoolz_rot)
      axisx$ = vequ(caxisx)
      xa = rotp (-csav, xa)
      cfeed_x = vequ(xa)
      pax_shift
      csav = csav + c$
      ipr_type = one

ppolar_fcyc     #Output values for face, polar conversion cycle
      xabs = (xa + dia_shift) * g137_mult
      yabs = zero
      zabs = (za + z_shift) * z_mult
      cabs = (ya + y_shift) * y_mult
      ipr_type = zero

pax_shift       #Apply multiplier and shift positions, csav was recalculated
      if posttype$ = one, xabs = (cfeed_x + dia_shift) * mill_mult
      else, xabs = (cfeed_x + dia_shift) * dia_mult
      yabs = (cfeed_y + y_shift) * y_mult
      zabs = (cfeed_z + z_shift) * z_mult

      #Apply axis shift for lower turrets
      if posttype$ <> two & (lathtype = zero | lathtype = two),
        csav = csav + c_shift
      if posttype$ = two,
        [
        yabs = zero
        csav = zero
        ]

pplane_mod    #Modify the multiplier based on plane, see psw_str_mult
      if plane$ = zero,
        [
        dia_mult = prv_dia_mult * pl_ax_m0x
        y_mult = prv_y_mult * pl_ax_m0y
        z_mult = prv_z_mult * pl_ax_m0z
        ]
      else,
        [
        if plane$ = one,
          [
          dia_mult = prv_dia_mult * pl_ax_m1x
          y_mult = prv_y_mult * pl_ax_m1y
          z_mult = prv_z_mult * pl_ax_m1z
          ]
        else, #plane = two
          [
          dia_mult = prv_dia_mult * pl_ax_m2x
          y_mult = prv_y_mult * pl_ax_m2y
          z_mult = prv_z_mult * pl_ax_m2z
          ]
        ]

pcoutrev        #Rotary axis revolution calculation (Modify for wind-up)
      if cir_at_zero = one,
        [
        #Arcs at center position the c axis
        if cuttype = -2 | abs(cuttype) = three,
        csav = czero_csav - sweep$
        else, csav = czero_csav + sweep$
        ]
      #C does not move going to CL
      if pnt_at_zero, csav = last_csav
      cdelta = fmtrnd(csav) - last_csav  #This calculates once, for rev
      while abs(cdelta) > ctol, #If motion exceeds ctol, add wind-up
        [
        if cdelta > zero,
          [
          rev = rev - one
          cdelta = cdelta - 360
          ]
        else,
          [
          rev = rev + one
          cdelta = cdelta + 360
          ]
        ]

      #if cwind & (toolchng | (toolchng0)), #CWIND IS NOT WORKING CORRECTLY ON EITHER SETTING MU00007
      #  [
      #  sav_rev = rev
      #  ]

      if cuttype <> four, c_wnd = rev * 360 + csav
      else, c_wnd = sav_rev * 360 + csav
      last_csav = csav
      @c_wnd
      #Now switch to c_wnd which is the absolute winding C calculation
      #Modify for shortest direction if toolchange or toolplane
      #but not with axis subs
      if c_axistype <> three,
        [
        if abs(prvc_wnd - c_wnd) > 180
          & (toolchng | (y_axis & cuttype < four)),
          [
          while abs(prvc_wnd - c_wnd) > 180,
            [
            if prvc_wnd > c_wnd, rev = rev + one
            else, rev = rev - one
            c_wnd = rev * 360 + csav
            ]
          @c_wnd
          ]
        ]

pindxcalc       #Index move calculations, direction is shortest exc. Asub
      if pnt_at_zero | cdelta = zero, indx_mc = prv_indx_mc
      else,
        [
        cdelta = fmtrnd(c_wnd) - prvc_wnd
        if cuttype = four, #Just look at the direction
          [
          if cdelta >= zero, indx_mc = one
          else, indx_mc = zero
          ]
        else,
          [
          #Phase shift delta 10 revolutions, check odd/even for direction
          if frac(int((cdelta + 3600)/180)/two), indx_mc = zero
          else, indx_mc = one
          ]
        ]
      #Set range 0-360
      while cabs < zero, cabs = cabs + 360
      while cabs > 360, cabs = cabs - 360

pfcalc          #Feedrate calculations, gcode 0 does not evaluate
      #if abs(c_wnd-prvc_wnd)<vtol$ | c_axistype=three | drillcur$
      #wbt added c_resolution. Post must only enter pfclc_deg_inv if C motion >= to the resolution of the axis output occurs
      if abs(c_wnd-prvc_wnd) < c_resolution | c_axistype=three | drillcur$
      | ipr_type=zero | prv_pnt_at_zero | gcode$ = zero, pfcalc_u_min
      else, pfclc_deg_inv

pfcalc_u_min    #Feedrate unit/min
      feed = fr_pos$
      if feed > maxfeedpm, feed = maxfeedpm
      if posttype$ = 1 & mi6$ = 1, feed = feed/speed         #test whether or not feed/rev is working with dpm
      prvfrdeg = feed

pfclc_deg_inv   #Feedrate deg/min, xa and ya are assumed relative to origin
      #Average last radius to current radius
      ldelta = ((cfeed_x+prv_cfeed_x)/two)^two+((cfeed_y+prv_cfeed_y)/two)^two
      circum = sqrt(ldelta) * two * pi$
      if circum = zero, circum = c9k          #Don't allow Zero
      ldelta = (cfeed_x-prv_cfeed_x)^two+(cfeed_y-prv_cfeed_y)^two
      ldelta = sqrt(ldelta+(cfeed_z-prv_cfeed_z)^two)
      cdelta = ((abs(c_wnd - prvc_wnd))/360)*circum
      if ldelta = zero, cldelta = cdelta
      else, cldelta = sqrt(cdelta^two + ldelta^two)
      if cldelta = zero, cldelta = c9k
      #Feedrate deg/min control and calculation
      frdeg = abs(cdelta/cldelta) * abs(fr_pos$ * (360/circum))
      if abs(frdeg - prvfrdeg) > frdegstp | ipr_type <> prv_ipr_type,
        [
        #Control output of frdeg
        prvfrdeg = frdeg
        feed = frdeg
        ]
      if fmtrnd(frdeg) = zero, feed = fr_pos$
      if frdeg > maxfrdeg, feed = maxfrdeg
      if posttype$ = 1 & feed < 0.1,feed = feed/speed         #test whether or not feed/rev is working with dpm

#Incremental calculations
ps_inc_calc     #Incremental calculations, start
      xia = fmtrnd(xabs)
      yia = fmtrnd(yabs)
      zia = fmtrnd(zabs)
      xinc = vsub (xia, prv_xia)
      if posttype$ <> two, ps_cinc_calc

ps_cinc_calc    #Incremental calculations, start rotary
      cia = fmtrnd(cabs)
      cinc = cia - prv_cia

pe_inc_calc     #Incremental calculations, end
      prvc_wnd = fmtrnd(c_wnd)      #Avoid updating until called explicitly
      !cfeed_x, !cfeed_y, !cfeed_z, !ipr_type  #These are used in pxyzcout
      !x$, !y$, !z$, !xa, !ya, !za
      !xia, !yia, !zia, !cia
      #!cc_pos$, !cutpos2     #01/23/04
      !cutpos2$     #01/23/04     #don't update cc_pos here as it doesn't allow for lathe cutter comp to function properly.

# --------------------------------------------------------------------------
# Mapping routines, maps input to basic machine coordinates (side view)
# --------------------------------------------------------------------------
pmatrix_su      #Setup mapping matrix
      hmtx1 = matt(m1$)
      hmtx1 = mmul(hmtx1, smtx1)
      if cuttype = one, mmtx1 = matt(m1$)
      if cuttype = two, mmtx1 = matt(smtx1)
      if cuttype =  -2,mmtx1 = matt(bmtx1)
      if cuttype = three | cuttype = five, mmtx1 = matt(cmtx1)
      if cuttype =  -3, mmtx1 = matt(crmtx1)
      if cuttype = four, mmtx1 = matt(amtx1)
      mmtx1 = mmul(mmtx1, smtx1)

pshft_map_xc    #Remove workshift and map to lathe coordinates, center
      xca = vadd (xc$, tox$)  #Always shift to origin
      if plane$ = one,
        [
        result = xca
        xca = zca
        zca = yca
        yca = result
        ]
      if plane$ = two,
        [
        result = yca
        yca = zca
        zca = result
        ]
      xca = vmap (xca, mmtx1)

pshft_map_ijk    #Remove workshift and map to lathe coordinates, ijk
      if arctype$ = one, #Absolute is shifted
        [
        if wcs_origin, iout = vadd (i$, tox$)
        else, iout = vequ (i$)
        ]
      else, iout = vequ (i$)
      iout = vmap (iout, mmtx1)

pshft_map_xa     #Remove workshift and map to lathe coordinates, xyz
      if wcs_origin, xa = vadd (copy_x, tox$)
      else, xa = vequ (copy_x)
      xa = vmap (xa, mmtx1)

pmap_home     #Set the location for home position
      xa = vequ(xh$)
      if map_home,
        [
        if wcs_origin, xa = vadd(xa, tox$)
        xa = vmap(xa, hmtx1)
        ]
      pplane_mod
      pxyzcout0 #basic toolplane positioning

pmap_plane    #Map NCI plane to machine plane
      mach_plane = plane$
      #Cross
      if cuttype=3 & plane$<two, mach_plane = abs(plane$ - one)
      #Top
      if (abs(cuttype)<=one | abs(cuttype)>=4),
      mach_plane = plane$ - one
      if mach_plane = m_one, mach_plane = two

# --------------------------------------------------------------------------
# NCI file pre-read look ahead routines
# Build the toolchange buffer, sets cycle and turret flags
# --------------------------------------------------------------------------
pwrttparam$      #Information from parameters
      #"pwrttparam", ~prmcode$, ~sparameter$, e$
      if prmcode$ = 15145, metvals   = rpar(sparameter$,1)
      if opcode$ = 104, result = fprm (opcode$)
      if prmcode$ = 15346, comp_type = rpar(sparameter$, 1)
      if prmcode$ = 20103, stinsert2 = sparameter$
      if prmcode$ = 20110, stholder2 = sparameter$

pwrtt$           #Buffer toolchange information, tooltable = 3 calls on 1003
      if gcode$ = 1001, psetup
      pcut_cctyp
      if opcode$=104 | opcode$=105 | opcode$=three | opcode$=16, cc_pos$ = zero
      if gcode$ <> 1001, plast_recd
      pcur_recd
      if gcode$ <> 1003, cc_pos$ = zero
      !opcode$, !tool_op$
      if gcode$ = 1003,
        [
        size1 = rbuf (one, zero)
        rc1 = one
        if rc1 < size1, preadcur_nxt
        if cc_1013$ = zero, cc_pos$ = zero
        ]
      #if you want repetitive tool output, keep the abs( ) in ptooltable and remove the >= t$ from the pwrtt call to this block
      if (tool_info = 2 | tool_info = 3) & gcode$ <> 1003 & op_id$ <> last_op_id & t$ >= 0, ptooltable
      last_op_id = op_id$

ptooltable # Write tool table, scans entire file, null tools are negative
           #if you want repetitive tool output, keep the abs( ) in ptooltable and remove the >= t$ from the pwrtt call to this block
           tnote = abs(t$)
           tldianote = abs(tldia$)
           if opcode$ = 3 |  opcode$ = 16, toffnote = tlngno$
           else, toffnote = tloffno$
           strtool$ = ucase(strtool$)
           stinsert2 = ucase(stinsert2)
           !spaces$
           spaces$ = zero
           if posttype$ = 2,    #lathe tools
             [
             #scomm_str, *tnote, ptspace, "-", e$
             scomm_str, *tnote," - " *toffnote," - ", strtool$, scomm_end, e$ # " - ", strtool$, " - " *toffnote, " - ", *stinsert, *stinsert2, " - ", *stholder, *stholder2, scomm_end, e$
             ]
           else,                  #mill tools
             [
             if opcode$ = 3 |  opcode$ = 16,
               [
               if tcr$ = 0, scomm_str, *tnote, ptspace, " - ", plistcomm, " - ", *tldianote, punit, pdiamspc, scomm_end, e$  #### added greater than sign to allow tooling informtaion on mill tools at top of program - JS
               ]
             else,
               [
               #if tcr$ > 0, scomm_str, *tnote, ptspace, " - ", plistcomm, " - ", *toffnote, pdspace, " - ", *tldianote, punit, pdiamspc, " - ", *tcr$,  punit, scomm_end, e$
               #if tcr$ = 0, scomm_str, *tnote, ptspace, " - ", plistcomm, " - ", *toffnote, pdspace, " - ", *tldianote, punit, pdiamspc,  scomm_end, e$
               ]
             ]
           spaces$ = prv_spaces$

plistcomm  # Comments from tool library
           strtool$=ucase(strtool$)
           if strtool$=snull, strtool$ = snocomm
           *strtool$

           nstrlen = strlen(strtool$)
           counter = 1
           while counter <= (20-nstrlen), pspace

pspace     # Creates spaces based on tool comment length
           32
           counter = counter + 1

ptspace    # Creates spaces based on tool number
           if t$ < 10, 32, 32
           if t$ >= 10 & t$ < 100, 32

pdspace    # Creates spaces based on diameter offset number
           if tloffno$ < 10, 32, 32
           if tloffno$ >= 10 & tloffno$ < 100, 32

pdiamspc   # Creates spaces based on diameter offset number
           #if tldia$ < 10, "  "

punit      # Tool unit
           if met_tool$, "mm"
           else, 34

pcur_recd       #Write to the current tool record
      c1_gcode = gcode$
      pmatrix_su
      pset_turret
      pmap_home
      c1_xh = vequ(xabs)
      c1_tox = vmap (tox$, mmtx1)
      c1_cc_pos = cc_pos$
      if gcode$ <> 1003, c1_tool = abs(t$)
      else, c1_tool = zero
      c1_tloffno = tloffno$
      c1_maxss = maxss$
      c1_ss = abs(ss$)
      if cool_w_spd = zero, c1_spdir = spdir$ + one
      else, c1_spdir = (spdir$ + one) + (fsg2(coolant$) * three)
      c1_css_actv = css_actv$
      c1_fr_pos = fr_pos$
      c1_ipr_actv = ipr_actv$
      c1_coolant = coolant$
      c1_nextdc = nextdc$
      c1_posttype = posttype$
      c1_cuttype = cuttype
      c1_lathtype = lathtype
      c1_gcodecc = gcodecc
      c1_lathecc = lathecc
      c1_millcc = millcc
      c1_y_axis = y_axis
      if opcode$ = 104,
        [
        if face_thd <> two, x_min$ = abs(xmaj_thd)
        else,
          [
          if abs(zstrt_thd) > abs(zend_thd), x_min$ = abs(zstrt_thd)
          else, x_min$ = abs(zend_thd)
          ]
        x_max$ = x_min$
        ]
      c1_spindle_no = spindle_no$
      c1_gcode = wbuf (one, wc1)

plast_recd      #Update the last record(s) for min-max and point
      rc1 = wc1 - one
      c1_gcode = rbuf (one, rc1)
      if prv_opcode$ <> 104,
        [
        c1_x_min = x_min$
        c1_x_max = x_max$
        ]
      rc1 = wc1 - one               #rc1 is used to write also
      c1_gcode = wbuf (one, rc1)

pcut_cctyp      #Find the type of cut for the tool buffer
                #y_axis
                #posttype
                #cuttype
                #lathtype
      y_axis = zero
      cuttype = zero
      if posttype$ = two, cuttype = one
      else,
        [
        if mill5$, cuttype = five
        else,
          [
          if rotary_type$ = one, cuttype = four
          else,
            [
            @m1$, @m2$, @m3$, @m7$, @m8$, @m9$
            if m7$ = m_one & m8$ = zero & m9$ = zero, cuttype =  -2
            if m7$ = one & m8$ = zero & m9$ = zero, cuttype = two
            if m1$ = m_one & m2$ = zero & m3$ = zero, cuttype = three
            if m1$ = one & m2$ = zero & m3$ = zero, cuttype =  -3
            if rotary_type$ = three | rotary_type$ = zero, y_axis = one
            ]
          ]
        ]
      lathtype = lturret$ + spindle_no$ * two
      #Check for errors
      if rotary_type$,
        [
        if (abs(cuttype) = two & rotary_axis$ <> three)
        | (abs(cuttype) = three & rotary_axis$ <> one),
          result = mprint(saxiserror)
        if cuttype = four & tlplnno$ <> one, result = mprint(stoperror)
        ]
      else,
        [
        if cuttype = zero, result = mprint(scutterror)
        ]
      #gcodecc, determine G74/G75 direction during processing
      #lathecc
      #millcc
      gcodecc = zero
      lathecc = zero
      if tool_op$ > 201,
        [
        if tool_op$ = 202 | tool_op$ = 203,
          [
          gcodecc = one
          lathecc = one
          if tool_op$ = 203, lathecc = m_one
          ]
        else,
          [
          if tool_op$ = 204 | tool_op$ = 205,
            [
            gcodecc = two
            lathecc = one
            if tool_op$ = 205, lathecc = m_one
            ]
          else,
            [
            if tool_op$ = 206 | tool_op$ = 207,
              [
              gcodecc = three
              lathecc = two
              if tool_op$ = 207, lathecc =  -2
              ]
            else,
              [
              if tool_op$ = 208,
                [
                gcodecc = four
                lathecc = three
                ]
              ]
            ]
          ]
        ]
      if mi4$<>zero & opcode$ <> three & (cuttype=four | abs(cuttype)=two),
         millcc = mi4$
      else, millcc = zero

psetup          #Setup post based on NCI settings
      sbufname3$ = spathnci$ + snamenci$ + sextext$
      spathext$ = spathnci$
      snameext$ = snamenci$
      #Set metric defaults
      if met_tool$ = one,
        [
        conversion = 1000
        vtol$ = vtol_m
        maxfeedpm = maxfeedpm_m
        lcc_move = lcc_move_m
        ]
        result = nwadrs (strb, thdang)
        result = nwadrs (stri, thdrdlt)
        result = nwadrs (strh, thddepth$)
        result = nwadrs (strd, thdfirst$)
        #Lathe canned cycle old style conversion
        result = nwadrs (strd, depthcc)
        result = nwadrs (strd, ncutscc)
        result = nwadrs (stri, g73x)
        result = nwadrs (strk, g73z)
        result = nwadrs (strd, grvspcc)
        result = nwadrs (strk, grvdpcc)
      result = nwadrs(str_cax_abs, cabs)
      result = nwadrs(str_cax_inc, cinc)
      result = nwadrs(str_index, indx_out)
      sc_minus = str_cax_abs + sc_minus
      breakarcss = breakarcs$

# --------------------------------------------------------------------------
# Turret and cut type change setup, do not edit
# --------------------------------------------------------------------------
pset_turret     #Set the machine conditions and mapping based on the turret
      if lathtype = one | use_only_tl, pltype1
      else,
        [
        if lathtype = zero, pltype0
        else,
          [
          if lathtype = two, pltype2
          else, pltype3
          ]
        ]
      psw_str_mult

pltype0         #Bottom turret/Left spindle
      if cuttype = one,
        [
        #Lathe
        max_speed = max_speedl0
        min_speed = min_speedl0
        sw_string = scase_bl_c1
        ]
      else,
        [
        #Mill
        max_speed = max_speedm0
        min_speed = min_speedm0
        sw_string = scase_bl_c2 #case two is the default
        if cuttype =  -2,sw_string = scase_bl_c_2
        if cuttype = three, sw_string = scase_bl_c3
        if cuttype = -3, sw_string = scase_bl_c3r
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_bl_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_bl_c4
        if cuttype = five, sw_string = scase_bl_c5
        ]

pltype1         #Top turret/Left spindle
      if cuttype = one,
        [
        #Lathe
        max_speed = max_speedl1
        min_speed = min_speedl1
        sw_string = scase_tl_c1
        ]
      else,
        [
        #Mill
        max_speed = max_speedm1
        min_speed = min_speedm1
        sw_string = scase_tl_c2 #case two is the default
        if cuttype =  -2,sw_string = scase_tl_c_2
        if cuttype = three, sw_string = scase_tl_c3
        if cuttype = -3, sw_string = scase_tl_c3r
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_tl_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_tl_c4
        if cuttype = five, sw_string = scase_tl_c5
        ]

pltype2         #Bottom turret/Right spindle
      if cuttype = one,
        [
        #Lathe
        max_speed = max_speedl2
        min_speed = min_speedl2
        sw_string = scase_br_c1
        ]
      else,
        [
        #Mill
        max_speed = max_speedm2
        min_speed = min_speedm2
        sw_string = scase_br_c2 #case two is the default
        if cuttype =  -2,sw_string = scase_br_c_2
        if cuttype = three, sw_string = scase_br_c3
        if cuttype = -3, sw_string = scase_br_c3r
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_br_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_br_c4
        if cuttype = five, sw_string = scase_br_c5
        ]

pltype3         #Top turret/Right spindle
      if cuttype = one,
        [
        #Lathe
        max_speed = max_speedl3
        min_speed = min_speedl3
        sw_string = scase_tr_c1
        ]
      else,
        [
        #Mill
        max_speed = max_speedm3
        min_speed = min_speedm3
        sw_string = scase_tr_c2 #case two is the default
        if cuttype =  -2,sw_string = scase_tr_c_2
        if cuttype = three, sw_string = scase_tr_c3
        if cuttype = -3, sw_string = scase_tr_c3r
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_tr_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_tr_c4
        if cuttype = five, sw_string = scase_tr_c5
        ]

psw_str_mult    #Apply sw_string to variables and strings
      #c axis type
      #c_axistype = plcval (sw_string, 8)    #c_axistype comes from machine def
      if rot_index = 1, c_axistype = 3
      else,
        [
        if rot_type = 0 | rot_type = 2, c_axistype = 1
        if rot_type = 1, c_axistype = 2
        ]
      #reverse spindle
      spd_rev = plcval (sw_string, 7)
      #plane 0
      rslt_plc = plcval (sw_string, 6)
      if rslt_plc = zero,
        [
        sg02 = sxg02
        sg03 = sxg03
        sg41 = sxg41
        sg42 = sxg42
        ]
      else,
        [
        sg02 = sxg03
        sg03 = sxg02
        sg41 = sxg42
        sg42 = sxg41
        ]
      #plane 1
      rslt_plc = plcval (sw_string, five)
      if rslt_plc = zero,
        [
        sg02_1 = sxg02
        sg03_1 = sxg03
        sg41_1 = sxg41
        sg42_1 = sxg42
        ]
      else,
        [
        sg02_1 = sxg03
        sg03_1 = sxg02
        sg41_1 = sxg42
        sg42_1 = sxg41
        ]
      #plane 2
      rslt_plc = plcval (sw_string, four)
      if rslt_plc = zero,
        [
        sg02_2 = sxg02
        sg03_2 = sxg03
        sg41_2 = sxg41
        sg42_2 = sxg42
        ]
      else,
        [
        sg02_2 = sxg03
        sg03_2 = sxg02
        sg41_2 = sxg42
        sg42_2 = sxg41
        ]
      #plane 0
      rslt_plc = plcval (sw_string, three)
      rslt_upd = updstr (swstr)
      sg17 = swstr
      #plane 1
      rslt_plc = plcval (sw_string, two)
      rslt_upd = updstr (swstr)
      sg19 = swstr
      #plane 2
      rslt_plc = plcval (sw_string, one)
      rslt_upd = updstr (swstr)
      sg18 = swstr
      #plane 0, x axis
      rslt_plc = plcval (sw_string, m_one)
      pl_ax_m0x = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -2)
      pl_ax_m0y = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -3)
      pl_ax_m0z = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -4)
      pl_ax_m1x = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -5)
      pl_ax_m1y = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -6)
      pl_ax_m1z = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -7)
      pl_ax_m2x = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -8)
      pl_ax_m2y = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string,  -9)
      pl_ax_m2z = -((rslt_plc * two) - one)

# --------------------------------------------------------------------------
# Post Text --  Use Control Definition Manager to modify
# --------------------------------------------------------------------------

[CTRL_TEXT_XML_BEGIN]  # Post text edits MUST be made with Control Definition Manager.
<?xml version="1.0" encoding="UTF-8"?>
<mp_xml_post_text xml:space="preserve">
	<control>
		<control_label>CTRL_MT_MILL|OKUMA_2SP-V760EXM_RIGHT</control_label>
		<language>en-US</language>
		<misc_integers>
			<misc_1>
				<text>""</text>
			</misc_1>
			<misc_2>
				<text>""</text>
			</misc_2>
			<misc_3>
				<text>""</text>
			</misc_3>
			<misc_4>
				<text>G107 = 1 for on 0 for off</text>
			</misc_4>
			<misc_5>
				<text>Synch Spindles [0=OFF,1=ON]</text>
			</misc_5>
			<misc_6>
				<text>""</text>
			</misc_6>
			<misc_7>
				<text>""</text>
			</misc_7>
			<misc_8>
				<text>Cut Mode 0=M32, 1=M33, 2=M34</text>
			</misc_8>
			<misc_9>
				<text>Infeed 0=M73, 1=M74, 2=M75</text>
			</misc_9>
			<misc_10>
				<text>""</text>
			</misc_10>
		</misc_integers>
		<misc_reals>
			<misc_1>
				<text>Enter PS Section Value</text>
			</misc_1>
			<misc_2>
				<text>Enter PM Section Value</text>
			</misc_2>
			<misc_3>
				<text>""</text>
			</misc_3>
			<misc_4>
				<text>""</text>
			</misc_4>
			<misc_5>
				<text>""</text>
			</misc_5>
			<misc_6>
				<text>""</text>
			</misc_6>
			<misc_7>
				<text>""</text>
			</misc_7>
			<misc_8>
				<text>""</text>
			</misc_8>
			<misc_9>
				<text>""</text>
			</misc_9>
			<misc_10>
				<text>""</text>
			</misc_10>
		</misc_reals>
		<simple_drill>
			<description>
				<text>Drill/Counterbore - G181</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>Dwell (E)</text>
			</dwell>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</simple_drill>
		<peck_drill>
			<description>
				<text>Peck Drill Cycle</text>
			</description>
			<dwell>
				<text>Dwell (E)</text>
			</dwell>
			<first_peck>
				<text>Peck Depth (D)</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</peck_drill>
		<chip_break>
			<description>
				<text>Chip Breaker Cycle</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>Dwell (E)</text>
			</dwell>
			<first_peck>
				<text>Peck Depth (D)</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>Peck Clearance (DA)</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</chip_break>
		<tap>
			<description>
				<text>Rigid Tap (G77/G78)</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</tap>
		<bore1>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</bore1>
		<bore2>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore2>
		<misc1>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</misc1>
		<drill_cycle_descriptions>
			<simple_drill>
				<text>Drill/Counterbore - G83</text>
			</simple_drill>
			<peck_drill>
				<text>Peck Drill - longhand</text>
			</peck_drill>
			<chip_break>
				<text>Drill/Peck - G83</text>
			</chip_break>
			<tapping>
				<text>Rigid Tap (G77/G78)</text>
			</tapping>
		</drill_cycle_descriptions>
		<canned_text>
			<canned_text_1>
				<text>Program Stop</text>
			</canned_text_1>
			<canned_text_2>
				<text>Optional Stop</text>
			</canned_text_2>
			<canned_text_3>
				<text>Block Delete on</text>
			</canned_text_3>
			<canned_text_4>
				<text>Block Delete off</text>
			</canned_text_4>
			<canned_text_5>
				<text>Return Tailstock</text>
			</canned_text_5>
			<canned_text_6>
				<text>Advance Tailstock</text>
			</canned_text_6>
			<canned_text_7>
				<text>Return Chute</text>
			</canned_text_7>
			<canned_text_8>
				<text>Advance Chute</text>
			</canned_text_8>
			<canned_text_9>
				<text>Exact Stop on</text>
			</canned_text_9>
			<canned_text_10>
				<text>Exact Stop off</text>
			</canned_text_10>
		</canned_text>
	</control>
<control>
		<control_label>CTRL_MT_LATHE|OKUMA_2SP-V760EXM_RIGHT</control_label>
		<language>en-US</language>
		<misc_integers>
			<misc_1>
				<text>""</text>
			</misc_1>
			<misc_2>
				<text>""</text>
			</misc_2>
			<misc_3>
				<text>""</text>
			</misc_3>
			<misc_4>
				<text>G107 = 1 for on 0 for off</text>
			</misc_4>
			<misc_5>
				<text>Synch Spindles [0=OFF,1=ON]</text>
			</misc_5>
			<misc_6>
				<text>""</text>
			</misc_6>
			<misc_7>
				<text>""</text>
			</misc_7>
			<misc_8>
				<text>Cut Mode 0=M32, 1=M33, 2=M34</text>
			</misc_8>
			<misc_9>
				<text>Infeed 0=M73, 1=M74, 2=M75</text>
			</misc_9>
			<misc_10>
				<text>""</text>
			</misc_10>
		</misc_integers>
		<misc_reals>
			<misc_1>
				<text>Enter PS Section Value</text>
			</misc_1>
			<misc_2>
				<text>Enter PM Section Value</text>
			</misc_2>
			<misc_3>
				<text>""</text>
			</misc_3>
			<misc_4>
				<text>""</text>
			</misc_4>
			<misc_5>
				<text>""</text>
			</misc_5>
			<misc_6>
				<text>""</text>
			</misc_6>
			<misc_7>
				<text>""</text>
			</misc_7>
			<misc_8>
				<text>""</text>
			</misc_8>
			<misc_9>
				<text>""</text>
			</misc_9>
			<misc_10>
				<text>""</text>
			</misc_10>
		</misc_reals>
		<simple_drill>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>Dwell (E)</text>
			</dwell>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</simple_drill>
		<peck_drill>
			<description>
				<text>Peck Drill Cycle</text>
			</description>
			<dwell>
				<text>Dwell (E)</text>
			</dwell>
			<first_peck>
				<text>Peck Depth (D)</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</peck_drill>
		<chip_break>
			<description>
				<text>Chip Breaker Cycle</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>Dwell (E)</text>
			</dwell>
			<first_peck>
				<text>Peck Depth (D)</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>Peck Clearance (DA)</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</chip_break>
		<tap>
			<description>
				<text>Rigid Tap (G77/G78)</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</tap>
		<bore1>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</bore1>
		<bore2>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore2>
		<misc1>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</misc1>
		<drill_cycle_descriptions>
			<simple_drill>
				<text>Drill/Counterbore - G83</text>
			</simple_drill>
			<peck_drill>
				<text>Peck Drill - longhand</text>
			</peck_drill>
			<chip_break>
				<text>Drill/Peck - G83</text>
			</chip_break>
			<tapping>
				<text>Rigid Tap (G77/G78)</text>
			</tapping>
		</drill_cycle_descriptions>
		<stock_transfer_custom_parameters>
			<custom_integer_1>
				<text>Cutoff Tool? [0=no output]</text>
			</custom_integer_1>
			<custom_integer_2>
				<text>Use Torque Skip?</text>
			</custom_integer_2>
			<custom_real_1>
				<text>Rapid Position</text>
			</custom_real_1>
			<custom_real_2>
				<text>Feed Position</text>
			</custom_real_2>
			<custom_real_3>
				<text>Tool Initial Position</text>
			</custom_real_3>
		</stock_transfer_custom_parameters>
	</control>
</mp_xml_post_text>
[CTRL_TEXT_XML_END]
